## MySQL

### 数据库的三大范式

- 1NF

	- 定义

		- 确保数据库字段的原子性

	- 例子

		- 字段 userInfo: '广东省 10086'

- 2NF

	- 定义

		- 满足1NF
		- 非主键列完全依赖于主键，而不能只依赖主键的一部分
		- 表必须有一个主键

	- 例子

		- student_course(student_no, student_name, age, course_name, grade, credit)，主键为(student_no, course_name)。其中学分完全依赖于课程名称，姓名年龄完全依赖学号，不符合第二范式，会导致数据冗余（学生选n门课，姓名年龄有n条记录）、插入异常（插入一门新课，因为没有学号，无法保存新课记录）等问题

- 3NF

	- 定义

		- 满足2NF
		- 非主键列必须直接依赖于主键，不能存在传递依赖

			- 即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况

	- 例子

		- 学生关系表为Student(student_no, student_name, age, academy_id, academy_telephone)，主键为"学号"，其中学院id依赖于学号，而学院地点和学院电话依赖于学院id，存在传递依赖，不符合第三范式

### 事务

- 定义

	- 事务 是一组操作的集合，它是一个不可分割的工作单位
	- 事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败

- 事务的四大特性

	- 分类

		- 原子性

			- 事务包含的所有操作要么全部成功，要么全部失败回滚

		- 一致性

			- 事务必须使数据库从一个一致性状态变换到另一个一致性状态
			- 一致性是事务的最终目的，原子性、隔离性、持久性都是为了实现一致性

		- 隔离性

			- 多个并发事务之间要相互隔离

		- 持久性

			- 一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

	- 实现

		- 原子性

			- undo log

				- 事务执行异常无法提交时，通过执行undo log中的撤销操作，实现事务回滚

		- 一致性

			- undo log+redo log

		- 隔离性

			- mvcc+锁

				- RR、RC级别

		- 持久性

			- redo log

				- 1、事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中
				- 2、过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性

- 事务的隔离级别

	- 分类

		- Serializable (串行化)

			- 通过强制事务排序(每次读写需要得到表级共享锁，读写互相阻塞) ，使之不可能相互冲突，从而解决幻读问题

		- Repeatable read(可重复读/RR)

			- MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。

				- 幻读

		- Read commited(读已提交/RC)

			- 一个事务只能看见已经提交事务所做的改变，可避免脏读的发生

				- 不可重复读、幻读

		- Read uncommited(读未提交)

			- 所有事务都可以看到其他未提交事务的执行结果

				- 脏读、不可重复读、幻读

	- 注意事项

		- MVCC只作用于 RC（Read Committed）和RR（Repeatable Read）级别
		- RU（Read Uncommitted） 级别总是读取最新的数据版本，而不是符合当前事务版本的数据行
		- RC和RR隔离级别的实现就是通过版本控制来完成
		- Serializable 会对所有读取的行都加锁(表级锁)

	- 操作

		- SELECT @@tx_isolation;  // 查看当前事物级别
		- set session transaction isolation level 事务隔离级别； // 设置事务隔离级别
		- 修改mysql.ini文件的transaction-isolation=

- 并发产生的问题？

	- 脏读

		- 在一个事务处理过程里读取了另一个未提交的事务中的数据(某一事务修改值后被另一事务读取后，又撤销了这个修改操作)

	- 不可重复读

		- 对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了

	- 幻读

		- 当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，就像产生幻觉一样，这就是发生了幻读。

- 脏读跟不可重复的区别？

	- 脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据

- 隔离级别产生的问题

	- RU

		- 读取未提交的数据，产生脏读；并未对不可重复读，幻读进行操作，会产生

	- RR

		- 多次读取的数据都一样，如果读取过程中有事务新增数据，还是只能读取未修改前的数据，但是数据库已经发生改变，报错，产生幻读

	- RC

		- 只能读取提交的数据，一个事务读取中有其它事务提交，产生不可重复读；如果读取过程中有事务新增数据，产生幻读

- 不可重复读和幻读的区别？

	- 幻读和不可重复读都是读取了另一条已经提交的事务，不同的是不可重复读的重点是修改，幻读的重点在于新增或者删除

- 什么是间隙锁？

	- 在索引记录之间的间隙上的锁，所谓间隙(GAP)就是键值在条件范围内但不存在的记录，对这个"间隙"加锁(next-key lock)
	- 保证某个间隙内的数据在锁定情况下不会发生任何变化

- 如何解决幻读？

	- 行锁只能锁住行，新插入记录要更新的是记录之间的“间隙”
	- 当前读情况下，引入间隙锁(next-key lock)；快照读情况下，通过mvcc避免。

- 为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘？

	- 在业务操作中，我们操作数据一般都是随机读写磁盘的
	- redo log日志文件是顺序写的，效率大于随机写(WAL)

- 快照读和当前读

	- 快照读

		- 读取的是记录数据的可见版本（ReadView，可能是过期的数据），不用加锁
		- 快照读情况下，Innodb通过mvcc机制避免了幻读，因为读取的是可见版本，不存在读取更高版本的记录；并且没有记录的添加
		- 不加锁的select

	- 当前读

		- 取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录。
		- 当前读情况下，可能会产生幻读，因为每次读取的都是最新数据，如果两次查询中间有数据插入，产生幻读----间隙锁
		- update、insert、delete、select....for update(排他锁)、select....lock in share mode(共享锁)

- MVCC机制和原理

	- 定义

		- 多版本并发控制 (Multi-Version Concurrency Control)，只有在InnoDB引擎下存在。

	- 作用

		- 采用了MVCC机制后，只有写写之间相互阻塞，读读、读写，写读操作都可以不阻塞。避免了同一个数据在不同事务之间的竞争，提高系统的并发性能。
		- 确保一个事务中读取的是同一个数据库版本快照
		- RC和RR隔离级别的实现就是通过版本控制来完成

	- 实现原理

		- 依赖

			- 数据库隐藏字段

				- trx_id：当前事务Id，通过其大小判断事务的时间顺序（每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。）
				- roll_pointer：回滚指针，指向当前行记录的上一个版本（undo log）
				- roll_id：没有主键时InnoDB自动生成的主键

			- undo log版本链

				- 每次对记录进行修改时，都会记录一条undo log信息，每条undo log信息都有一个roll_pointer属性，指向上一个版本的行记录。
				- 链表形式连接，链表的头部是最新的旧记录，链表尾部是最早的旧记录

			- ReadView

				- 定义

					- 数据库中某一个时刻所有未提交事务的快照，可以知道这个时间点上未提交事务的所有信息.
					- 事务执行快照读（不加锁的select）的时候生成的

				- 参数

					- creator_trx_id：创建readview的当前事务id
					- m_ids：当前系统正在活跃的读写事务的事务Id列表
					- min_trx_id：当前系统中活跃的读写事务的最小事务Id
					- max_trx_id：当前时间戳InnoDB将在下一次分配的事务id（当前事务的id+1）

		- 原理

			- 核心处理逻辑

				- 通过ReadView判断所有版本中哪个版本是当前事务可见的处理

			- 逻辑判断

				- trx_id=creator_trx_id

					- 数据是当前事务修改的，可以访问

				- trx_id<min(ReadView)

					- 该版本的事务在生成 ReadView 前已经提交，可以被当前事务访问

				- trx_id>max(ReadView)

					- 该版本的事务在生成 ReadView 后才生成，不可以被当前事务访问

				- min(ReadView)<trx_id<max(ReadView)

					- trx_id∈m_ids

						- 创建ReadView时生成该版本的事务还是活跃的，不可访问

					- trx_id∉m_ids

						- 创建ReadView时生成该版本的事务已经被提交，可以访问

			- RC与RR的区别

				- RC：每次查询(select)都会生成新的ReadView，可能产生不可重复读
				- RR：当前事务第一次查询(select)时生成，并且生成的ReadView会一直沿用到事务提交为止，保证可重复读

		- RC与RR的实现

			- RC

				- 事务的每次快照读都生成一个ReadView，根据所生成的ReadView以及ReadView的版本链访问规则，到undolog版本链中匹配数据

			- RR

### 存储引擎

- 定义

	- 存储引擎就是指表的类型以及表在计算机上的存储方式
	- 以表为单位

- 分类

	- InnoDB

		- 定义

			- 一种兼顾高可靠性和高性能的通用存储引擎(5.5后默认存储引擎)

		- 特点

			- 支持事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全
			- DML操作遵循ACID模型，支持事务
			- 支持AUTO_INCREMENT，自增列必须为主键
			- 支持外键（FOREIGN KEY），保证数据的完整性和正确性
			- 支持自动在内存中创建自适应hash索引
			- 优势在于提供了良好的事务处理、崩溃修复能力和并发控制，引入了行级锁和外键约束。缺点是读写效率较差，占用的数据空间相对较大。

		- 存储

			- 每张表存储为一个文件(.ibd)，存储表的结构(旧-frm，新-sdi)、数据和索引

		- 逻辑存储结构

			- 表空间(TableSpace)

				- InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件(实际磁盘文件)，在表空间中可以包含多个Segment段

			- 段(Segment)

				-  表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等,一个段中包含多个区(InnoDB自动管理)

			- 区(Extent)

				- 区是表空间的单元结构，每个区的大小为1M，每个区有64个连续的页

			- 页(Page)

				- 组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，默认大小为16K(为了保证页的连续性，每次申请4-5个区)

			- 行(Row)

				- InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的
				- 除了定义表的字段，还有隐藏字段

					- 隐藏列(表隐藏字段)

						- trx_id：当前事务Id，通过其大小判断事务的时间顺序
						- roll_pointer：回滚指针，指向当前行记录的上一个版本
						- roll_id：没有主键时InnoDB自动生成的主键

	- MyISAM

		- 定义

			- MySQL早期的默认存储引擎

		- 特点

			- 不支持事务，不支持外键
			- 支持表锁，不支持行锁
			- 访问速度快
			- 优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性，不支持行级锁、崩溃后的安全修复、外键约束。

		- 存储

			- MyISAM的表存储成3个文件，文件的名字与表名相同。

				- frm文件存储表的结构
				- myd文件存储数据(MYData）
				- myi文件存储索引(MYIndex）

	- MEMORY

		- 定义

			- 表数据时存储在内存中的存储引擎，只能将这些表作为临时表或缓存使用

		- 特点

			- 内存存放
			- hash索引（默认）
			- 默认使用哈希索引，可以在创建索引时指定B+树索引
			- 访问速度快；具有hash索引的所有缺点
			- 对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性

		- 存储

			- MEMORY存储引擎的表实际对应一个磁盘文件(frm)
			- 文件中只存储表的结构，而其数据文件，都是存储在内存中。

	- 

- 如何选择

	- 对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票）；需要频繁的更新、删除操作的数据库  -----InnoDB

		- 支持事务处理，支持外键，支持崩溃修复能力和并发控制

	- 主要用于插入新记录和读出记录，对事务的完整性，并发性要求不高   ----MyISAM

		- 插入数据快，空间和内存使用比较低

	- 需要很快的读写速度，对数据的安全性要求较低  ----MEMORY

		- 数据的处理速度快，但是安全性不高

- MyISAM和InnoDb的区别？

	- 是否支持行级锁

		- MyISAM只有表级锁；InnoDB支持行级锁和表级锁

	- 是否支持事务和崩溃后的安全恢复

		- MyISAM不提供事务；InnoDB提供事务处理，具有事务、回滚、崩溃修复功能

	- 是否支持外键

		- MyISAM不支持；InnoDB支持

	- 是否支持MVCC

		- MyISAM不支持；InnoDB支持

	- 是否支持聚集索引

		- MyISAM不支持；InnoDB支持

- 操作

	- 修改

		- my.ini文件中的default-stoerage-engine
		- create table User() engine=?

	- 查看

		- show create table User;

### 索引

- 什么是索引？

	- 存储引擎用于提高数据库表的访问速度的一种数据结构，这个数据结构以某种方式引用（指向）数据
	- 每个索引对应一棵B+树

- 优缺点

	- 优点

		- 加快数据查找的速度
		- 加快表与表的连接
		- 加快分组和排序的速度

	- 缺点

		- 索引需要占用物理空间
		- 降低表的增删改的效率，因为每次都会动态维护索引表

- 分类

	- 单列索引

		- 主键索引

			- 是一种特殊的唯一索引，不允许有空值(primary key)

		- 唯一索引

			- 索引列中的值必须是唯一的，但是允许为空值(unique)

		- 普通索引

			- MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。

	- 组合索引

		- 在表中的多个字段组合上创建的索引，遵循最左前缀集合(原则)。

	- 全文索引

		- 只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引(full text)
		- 通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。

- InnoDB索引

	- 主键索引(聚簇索引)

		- 数据与索引一起存储，叶子节点存的是整行数据(一个)

	- 非主键索引(二级索引、非聚集索引)

		- 数据与索引分开存储，叶子节点内容是主键的值(多个)

- 自适应Hash索引

	- InnoDB没有直接支持hash索引，提供了自适应hash索引
	- InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引
	- 无需人工干预，是系统根据情况自动完成。
	- adaptive_hash_index

- 联合索引

	- 定义

		- 在表中的多个字段组合上创建的索引，遵循最左前缀集合(原则)。

	- 特点

		- 1、根据最左边的字段创建二级索引
		- 2、创建时首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序（叶子节点）

	- 示例图

		- 

- 最左匹配(前缀)原则

	- 1、如果SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，遇到范围查询(>、<、between、like)就会停止匹配(第一个索引必须是等值匹配)
	- 2、MySQL创建联合(复合)索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。
	- 3、构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建

- 索引的数据结构？

	- B+tree

		- 定义

			- 本质就是一棵多路平衡查找树(Balance Tree)，对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据。

		- 分类

			- 聚簇索引

				- 叶子节点存储了当前的key值以及整行的数据

			- 非聚簇索引

				- 叶子节点存储的不是记录的指针，而是主键的值
				- 先去二级索引查询，再去主键索引去查（回表查询）

			- 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个unique唯一键(不允许为空)建立聚簇索引.如果没有唯一键,则隐式的生成一个键roll_id来建立聚簇索引。

		- 注意事项

			- 1、叶子节点(数据页)以双向链表连接，数据页中的行数据(rows)以单向链表连接
			- 子主题 2

	- Hash

		- 定义

			- 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中
			- 进行查找时,调用一次hash函数就可以获取到相应的键值，将 Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，之后进行回表查询获得实际数据。

		- 特点

			- 1、Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）
			- 2、无法利用索引完成排序操作
			- 3、查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了

		- 操作

			- 新增一个被索引的列，使用crc32做hash函数

		- 存储引擎支持

			- Memory
			- InnoDB

				- 自适应，根据B+tree索引在指定条件下自动创建

	- R-tree(空间索引)

		- MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型

	- Full-text(全文索引)

		- 通过建立倒排索引,快速匹配文档的方式

- SQL性能分析

	- 执行频率

		- 定义

			- 查看当前各种sql语句的执行频率

		- 操作

			- show  session | global status

	- 慢查询日志

		- 定义

			- 记录在mysql执行过程超过指定时间的查询语句（默认10s)

		- 操作

			- /etc/my.cnf

				- slow_query_log=1

					- 开启慢查询

				- long_query_time=2

					- 记录时间

		- 作用

			- 定位出执行效率比较低的SQL，从而有针对性的进行优化

	- profile

		- 定义

			- 获取一个查询在整个执行过程中各个资源消耗情况,例如 CPU，IO，SWAP

		- 操作

			- select @@have_profiling   -- 是否支持profile
set global profiling = 1;  -- 开启
show profiles  -- 查看每一条SQL的耗时基本情况
show profile for query query_id;  -- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile cpu for query query_id;  -- 查看指定query_id的SQL语句CPU的使用情况

	- explain

		- 定义

			- mysql的执行计划，显示了mysql如何使用索引来处理select语句以及连接表

		- 字段含义

			- id

				- select查询的序列号，表示查询中执行select子句或者是操作表的顺序
				- id相同，执行顺序从上到下；id不同，值越大，越先执行

			- select_type

				- 查询类型

					- SIMPLE（简单表，即不使用表连接或子查询）
					- PRIMARY（主查询，即外层的查询）
					- UNION（UNION 中的第二个或者后面的查询语句）
					- SUBQUERY（SELECT/WHERE之后包含了子查询）

			- table

				- 查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表

			- partitions

				- 查询时匹配到的分区信息

			- type

				- 连接类型

					- null、system、const、eq_ref、ref、range、 index、all

			- possible_key

				- 显示可能应用在这张表上的索引，一个或多个

			- key 

				- 实际使用的索引，如果为NULL，则没有使用索引

			- key_len

				- 索引中使用的字节数， 该值为索引字段最大可能长度

			- ref

				- const(常量等值查询)，func(表达式、函数)，null，字段名(关联查询的字段)

			- rows

				- mysql认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值

			- filtered 

				- 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好

			- Extra

				- explain的额外信息

- 索引的使用

	- 最左前缀法则

		- 定义

			- 如果索引了多列（联合索引），要遵守最左前缀法则
			- 查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效。

		- 注意事项

			- 1、最左边的列必须存在，否则索引全部失效
			- 2、联合索引最左边的字段存在即可，与条件的编写顺序无关
			- 3、联合索引遇到范围查询(>、<、between、like)就会停止匹配（>=、<=不会失效）

	- 索引失效的情况
	- SQL提示

		- 定义

			- 执行sql时指定索引

		- 操作

			- user index(index_name)

				- 不一定使用

			- ingore index(index_name)

				- 忽略

			- force index(index_name)

				- 强制使用

	- 覆盖索引

		- 定义

			- 索引的叶子节点包含了要查询的数据，也就是索引包含（亦称覆盖）所有需要查询的字段的值

		- 例子

			- selet id,name from tb_user where name = 'Arm';

				- 根据name二级索引查询，节点中有id，无需回表

			- selet id,name,gender from tb_user where name = 'Arm'

				- 根据name二级索引查询，节点中有id，无gender，需要回表

	- 前缀索引

		- 定义

			- 将字符串的一部分前缀，建立索引

		- 前缀长度

			- 根据选择性来决定，选择性越接近1越好
			- 选择性

				- 选择性是指不重复的索引值（基数）和数据表的记录总数的比值
				- select count(distinct email) / count(*) from tb_user ;
				- select count(distinct substring(email,1,5)) / count(*) from tb_user ;

		- 查询流程

			- 根据前缀长度对字段值建立二级索引
			- 查询时截取查询字段值的部分去查询二级索引

		- 作用

			- 当字段类型为字符串时可能会索引很长的字符串，索引增大，浪费空间
			- 节约索引空间，从而提高索引效率

	- 单列索引与联合索引

		- 存在多个查询条件，考虑针对于查询字段建立索引时，更多的是建立联合索引，而非单列索引
		- 联合索引包含的信息更多，覆盖索引发生的情况更多，回表查询的频率更低

- B树和B+树
- B树和B+树
- B树和B+树

	- b树的好处

		- B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率

			- 特定数据重复多次查询的场景

	- B+树相比于B树的优势

		- 1、B+树的查询效率更加稳定 

			- 数据存储在叶子节点，每次查询时间复杂度固定

		- 2、B+树更适合范围查询

			- B+树叶子节点之间通过链表连接，只需一次中序遍历，适合范围查询；B树需要遍历整棵树

		- 3、B+树的磁盘读写代价更低

			- B+树的内部节点只存放键，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围

		- 4、B+树更有利于对数据库的扫描

			- B+树只需要一次中序遍历叶子节点就可以解决对全部关键字信息的扫描，B树遍历表耗时长

		- 5、B+树增删操作时效率更高

			- 叶子节点存储数据，并以链表链接形成双向有序链表（头尾相连）

- 聚集索引的选取规则？

	- 1、如果存在主键，主键索引就是聚集索引。
	- 2、如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
	- 3、如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引

- 什么是回表查询？

	- 通过二级索引不能查到所有数据，需要通过二级索引中的id再去聚集索引中进行查找的过程

- 为什么尽量建立联合索引而不是单列索引？

	- 联合索引包含的信息更多，覆盖索引发生的情况更多，回表查询的频率更低
	- 联合索引可以减少回表查询

- 索引失效的情况？(全表扫描)

	- 1、组合索引，不满足最左匹配原则
	- 2、like 以%开头，索引无效；前缀没有%，后缀有%时，索引有效。没有确定的值索引无效。
	- 3、当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效
	- 4、数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描
	- 5、索引列上使用 IS NULL 或 IS NOT NULL操作，索引不索引空值
	- 6、对索引字段进行计算操作、字段上使用函数，因为不带任何条件
	- 7、索引字段上使用not，<>，!=，不等于操作符是永远不会用到索引的
	- 8、数据分布影响，Mysql评估使用索引比全表扫描效率低，不走索引

		- 例如范围查询的数据到的数据占大多数、IS NOT NULL的行数占大多数等

- 索引的设计原则

	- 1、针对于数据量较大，且查询比较频繁的表建立索引
	- 2、常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立
	- 3、尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高
	- 4、 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引
	- 5、尽量使用联合索引，减少单列索引
	- 6、要控制索引的数量
	- 7、如果索引列不能存储NULL值，创建表时使用NOT NULL约束

- 为什么InnoDB存储引擎选择使用B+tree索引结构?

	- 1、相对于二叉树，层级更少，搜索效率高（数据量较大）
	- 2、对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。
	- 3、 相对Hash索引，B+tree支持范围匹配及排序操作

- 为什么Hash不支持范围查询？

	- hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询，hash函数具有不可预测性

- B+与Hash的区别

	- hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询
	- hash索引不支持使用索引进行排序
	- hash索引不支持模糊查询以及多列索引的最左前缀匹配
	- hash索引查询不稳定，因为存在hash碰撞
	- hash索引都要回表查询数据；B+树符合条件(聚簇索引,覆盖索引等)可以只通过索引完成查询

- B与B+的区别

	- B树的数据指针存储在各层节点中 ; B+树的数据都存储在了叶子节点，其余节点存放的是索引key值
	- B+树叶子节点按照本身关键字的大小顺序连接

- B+树相比于B树的优势

	- 1、B+树的查询效率更加稳定 

		- 数据存储在叶子节点，每次查询时间复杂度固定

	- 2、B+树更适合范围查询

		- B+树叶子节点之间通过链表连接，只需一次中序遍历，适合范围查询；B树需要遍历整棵树

	- 3、B+树的磁盘读写代价更低

		- B+树的内部节点只存放键，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围

	- 4、B+树更有利于对数据库的扫描

		- B+树只需要一次中序遍历叶子节点就可以解决对全部关键字信息的扫描，B树遍历表耗时长

	- 5、B+树增删操作时效率更高

		- 叶子节点存储数据，并以链表链接形成有序链表（头尾相连）

- 为什么B+树比B树更好(非叶子几点不存储数据)？

	- B树的数据指针存储在各层节点中 ; B+树的数据都存储在了叶子节点，其余节点存放的是索引key值
	- B+树叶子节点之间通过链表连接，只需一次中序遍历，适合范围查询；B树需要遍历整棵树
	- B+树查询更稳定，所有关键字查询的路径长度相同
	- B树插入操作需要旋转，耗时

- B+树的树高如何影响磁盘I/O次数？

	- InnoDB存放数据的单位是页，每一页的大小为16KB。每一个数据页存放的都是同一个高度的树节点，树高越小，磁盘I/O越少；

- 为什么hash索引无法避免回表扫描？

	- 由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，
	- 也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较。

- 聚集索引和非聚集索引

	- 聚集索引

		- InnoDB默认使用(主键索引就是聚簇索引)
		- 索引和数据是存放同一个文件中，其叶子节点中存放的就是整张表的行记录数据
		- 每个叶子节点包含主键值、事务ID、回滚指针(rollback pointer用于事务和MVCC）和余下的列
		- 一个表只能拥有一个聚集索引，可以有多个非聚集索引

			- 一个主键树，多个二级索引树

	- 非聚集索引

		- MyISAM默认使用
		- 索引文件和数据文件是分开的

- 什么是聚集索引？

	- 数据行的物理顺序与列值的顺序相同
	- 使用表的主键构造主键索引树，并且叶子节点中存放的是整张表的记录数据
	- 叶子节点逻辑上是连续的，使用双向链表连接，按照主键的顺序排序，InnoDB主键使用的是聚集索引。

- 什么是覆盖索引?

	- 如果索引的叶子节点包含了要查询的数据，那么就不用回表查询了，也就是说这种索引包含（亦称覆盖）所有需要查询的字段的值。

- 为什么用B+树做覆盖索引？

	- 覆盖索引要存储索引列的值，哈希索引和全文索引不存储

- 索引的作用？

	- 数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。

- 索引建立的情况？

	- 建立

		- 经常用于查询的字段
		- 经常用于连接的字段建立索引，可以加快连接的速度
		- 经常需要 排序 的字段建立索引，因为索引已经排好序，可以加快 排序 查询速度

	- 不建立

		- where条件中用不到的字段不适合建立索引
		- 表记录较少
		- 需要经常增删改
		- 参与列计算的列不适合建索引
		- 区分度不高的字段不适合建立索引，如性别等

- 索引的设计原则？

	- 区分度足够高
	- 数量一定
	- 尽量使用短索引，减少磁盘I/O次数
	- 利用最左前缀原则

- 主键索引和普通索引的查询有什么区别?

	- 主键查询方式，则只需要搜索主键索引这棵B+树
	- 普通索引查询方式，则需要先搜索二级索引树，得到id的值为，然后到ID索引树搜索一次(回表)

### SQL优化

- 子分类

	- 1、插入数据

		- 1、批量插入数据
		- 2、手动控制事务

			- set @@autocommit = 0 ;  -- 手动提交
start transaction;  -- 开启事务
insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
commit;  -- 提交事务

		- 3、主键顺序插入，性能要高于乱序插入
		- 4、大批量插入数据使用load指令

	- 2、主键优化

		- 页分裂

			- 定义

				- 一行的数据过大，发生页溢出，通过页分裂解决
				- 每个页包含了2-N行数据，只包含一行导致页与页之间形成单链表
				- 主键乱序插入时才会发生（聚集索引）

			- 现象

				- 要存储的记录存储的页空间不足，生成一个新的页，将其50%移动到这个新页，插入数据，修改指针指向

		- 页合并

			- 定义

				- 页中删除的记录达到 MERGE_THRESHOLD(页的50%)，InnoDB寻找最靠近的页尝试进行合并
				- Mysql删除数据时没有马上物理删除，只是将记录标记为删除并且允许它的空间被使用

		- 主键索引设计原则

			- 1、满足业务需求的情况下，尽量降低主键的长度
			- 2、插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。

				- 主键顺序插入 > 乱序插入

			- 3、尽量不要使用UUID做主键或者是其他自然主键，如身份证号。

				- 乱序插入效率低，还有页分裂

			- 4、业务操作时，避免对主键的修改

	- 3、order by优化

		- Mysql排序方式

			- Using filesort

				- 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作（缓冲区不足使用磁盘文件）

			- Using index

				- 通过有序索引顺序扫描直接返回有序数据，不需要额外排序，性能高

		- 注意事项

			- 1、联合索引建立时从第一个字段开始排序，并且是升序排序，对联合索引字段排序时需考虑这个规则
			- 2、可以在创建联合索引时指定字段的排序方式

				- create index idx_user_age_phone_ad on tb_user(age asc ,phone desc);

		- 优化原则

			- 1、根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。
			- 2、尽量使用覆盖索引
			- 3、多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）
			- 4、如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)

	- 4、group by优化

		- 1、分组操作中联合索引	也是符合最左前缀法则的，使用索引时满足法则

			- 多个字段联合索引

		- 2、为分组的字段建立索引，使用索引时满足法则

			- 单个字段添加普通索引

	- 5、limit优化

		- 通过覆盖索引加子查询优化

			- select s.* from tb_sku t , (select id from tb_sku order by idlimit 2000000,10) a where t.id = a.id;
			- 防止回表查询

	- 6、count优化

		- 用法

			- count(字段)

				- 无not null

					-  InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加

				- 有not null

					- InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加

			- count(主键)

				- InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加

			- count(1)

				- InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。

			- count(*)

				- InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加

		- 效率

			- count(字段) < count(主键) < count(1) <= count(*)

	- 7、update优化

		- InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁
		- update字段尽量根据索引字段进行更新，根据非索引字段更新时加表锁，避免升级为表锁

- 总分类

	- 1、避免不走索引的场景

		- 1、尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描
		- 2、尽量避免使用in 和not in，会导致引擎走全表扫描
		- 3、尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描
		- 4、尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描
		- 5、尽量避免在where条件中等号的左侧进行表达式、函数操作
		- 6、查询条件不能用 <> 或者 !=

	- 2、SELECT语句其他优化

		- 1、避免出现select *

			- 优化器无法完成索引覆盖扫描这类优化

		- 2、避免出现不确定结果的函数

			- 不确定结果的函数很容易导致主库与从库相应的数据不一致

		- 3、多表关联查询时，小表在前，大表在后

			- 执行 from 后的表关联查询是从左往右执行的，第一张表会涉及到全表扫描

		- 4、使用表的别名

			- 减少SQL解析的时间并减少那些因列名歧义引起的语法错误

		- 5、用where字句替换HAVING字句

			- HAVING只会在检索出所有记录之后才对结果集进行过滤

		- 6、调整where字句中的连接顺序

			- MySQL采用从左往右，自上而下的顺序解析where子句
			- 将过滤数据多的条件往前放，最快速度缩小结果集

	- 3、增删改 DML 语句优化(涉及事务，能回滚的属于DML)

		- 1、同时执行大量的插入

			- Insert into T values(1,2),(1,3),(1,4);
			- 减少SQL语句解析的操作

		- 2、适当使用commit

			- commit可以释放事务占用的资源而减少消耗

				- 事务占用的undo数据块
				- 事务在redo log中记录的数据块
				- 释放事务施加的锁，减少锁争用影响性能

		- 3、避免重复查询更新的数据

			- 使用变量记录查询后的某些结果(select @temp=?)

	- 4、查询条件优化

		- 1、对于复杂的查询，可以使用中间临时表 暂存数据
		- 2、优化group by语句

			- 可以使用order by null禁止排序

		- 3、优化join语句

			- 子查询用join...on替代，不需要创建临时表，效率更高

		- 4、优化union查询

			- MySQL通过创建并填充临时表的方式来执行union查询
			- 使用union all
			- 不加all，MySQL会给临时表加上distinct，做唯一性检验耗时间

		- 5、拆分复杂SQL为多个小SQL，避免大事务

			- 简单的SQL容易使用到MySQL的QUERY CACHE

		- 6、使用truncate代替delete

	- 5、建表优化

		- 1、在表中建立索引，优先考虑where、order by使用到的字段
		- 2、尽量使用数字型字段（如性别，男：1 女：2）
		- 3、用varchar/nvarchar 代替 char/nchar

			- 首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些

### 锁

- 定义

	- 锁是计算机协调多个进程或线程并发访问某一资源的机制
	- 保证数据并发访问的一致性、有效性

- 共享锁和拍他锁

	- 排他锁（X或写锁）

		- 一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁

	- 共享锁（S或读锁）

		- 共享锁就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有

- 分类

	- 全局锁

		- 定义

			- 锁定数据库中的所有表
			- 对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞，允许查询。

		- 存在的问题

			- 1、如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
			- 2、如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟

		- 操作

			- flush tables with read lock ; 	-- 加全局锁
mysqldump -uroot –p1234 itcast > itcast.sql  -- 进行数据备份
unlock tables ; 	 -- 释放全局锁
			- InnoDB在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份（快照读）

		- 场景

			- 全库的逻辑备份

				- 对所有的表进行锁定，从而获取一致性视图，保证数据的完整性

	- 表级锁

		- 定义

			- 每次操作锁住整张表的锁
			- 锁定粒度最大，触发锁冲突的概率最高，并发度最低
			- 实现简单，资源消耗也比较少，加锁快，不会出现死锁

		- 分类

			- 表锁

				- 分类

					- 读锁（共享）
					- 写锁（独占）

				- 操作

					- lock tables 表名... read/write  -- 加锁
					- unlock tables / 客户端断开连接     -- 释放锁

				- 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写

			- 元数据锁(Mete Data Lock)

				- 定义

					- 1、系统自动控制，访问一张表时自动加上的锁
					- 2、表上有活动事务的时候，不可以对元数据进行写入操作（避免dml与ddl冲突，保证读写的正确性）
					- 3、某一张表涉及到未提交的事务时，是不能够修改这张表的表结构
					- 4、对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)

				- 分类

					- mdl读(共享)锁

						- select、insert、update、delete

					- mdl写(拍他)锁

						- alter table...

				- 注意事项

					- 1、元数据共享锁之间兼容
					- 2、元数据共享与拍他锁之间户互斥

			- 意向锁

				- 定义

					- 对行加行锁的同时对整张表加意向锁
					- 使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查

				- 分类

					- 意向共享锁(IS)

						- select ... lock in share mode

					- 意向排他锁(IX)

						- insert、update、delete、select...for update

				- 注意事项

					- 1、意向共享锁与表读锁是兼容的
					- 2、意向排他锁与表读锁、写锁都是互斥的

	- 行级锁

		- 定义

			- 每次操作锁住对应的行数据（锁住的是对应行的索引）
			- 锁定粒度最小，发生锁冲突的概率最低，并发度最高

		- 分类

			- 行锁（Record Lock）

				- 定义

					- 锁定单个行记录的锁
					- 防止其他事务对此行进行update和delete（RR、RC都支持）

				- 分类

					- 共享锁（S）

						- select ... lock in share mode

					- 排他锁（X）

						- insert、update、delete、select...for update

				- 注意事项

					- 1、共享锁与排他锁之间互斥
					- 2、排它锁与排他锁之间互斥
					- 3、无索引行锁升级为表锁(条件查询时没有使用索引)
					- 4、主键、唯一、普通索引都是使用行锁(InnoDB)
					- 5、锁是针对索引加的锁，虽然访问的是不同行的记录，如果使用相同的索引键，会出现锁冲突

			- 间隙锁（Gap Lock）

				- 定义

					- 锁定索引记录间隙（不含该记录）
					- 确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读（RR下支持）

				- 作用

					- 防止其他事务插入间隙
					- 间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁

			- 临键锁（Next-Key Lock）

				- 定义

					- 行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap
					- InnoDB在RR级别运行，防止幻读

				- 加锁

					- 索引上的等值查询(唯一索引)

						- 给不存在的记录加锁时, 给这个区间加间隙锁，也就是后一个记录加间隙锁

					- 索引上的等值查询(非唯一普通索引)

						- 对该记录加临键锁，并对后一个不满足条件的值加间隙锁
						- 二级索引不唯一，可能存在多个，对索引记录前后都要进行加锁

					- 索引上的范围查询(唯一索引)

						- 会一直遍历到不满足条件为止
						- 对查询的条件记录(id>=20)加行锁，查询到的记录加间隙锁（可加正无穷的间隙锁）

- 表锁添加过程

	- 对这张表加表锁时，从第一行数据，检查到最后一行数据，检查当前表是否有对应的行锁，没有就添加

- 分类
- 分类
- 分类

	- 粗粒度

		- 行锁、表锁、页锁

	- 使用方式

		- 共享锁(读锁)、排它锁(写锁)（悲观锁的一种实现）

- Mysql本身的锁

	- 表级锁

		- 对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁
		- 锁定粒度最大，触发锁冲突的概率最高，并发度最低
		- 粒度最大 的一种锁

	- 行级锁

		- 只针对当前操作的行的索引进行加锁
		- 加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
		- 粒度最小 的一种锁

	- 排他锁（X或写锁）

		- 一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁

	- 共享锁（S或读锁）

		- 共享锁就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有

- InnoDB显示加表锁

	- LOCK TABLE table_name READ;   // 共享锁
LOCK TABLE table_name WRITE; //排他锁
UNLOCK tables;  // 解锁

- InnoDB锁

	- 分类

		- select

			- 需要显示加锁
			- 共享锁

				- select ......  lock in share mode;

					- 在事务中都会自动默认加上行级排他锁

			- 排他锁

				- select ...... for update

		- insert,update,delete

			- 默认行锁，对索引进行加锁

	- 锁的特性

		- 如果查询条件用了索引/主键，那么 select … for update 就会进行行锁
		- 如果是普通字段(没有索引/主键)，那么 select … for update 就会进行锁表。

	- 注意事项

		- 1、不通过索引条件查询时，InnoDB使用表锁
		- 2、MySQL的行锁是针对索引加的锁，虽然访问的是不同行的记录，如果使用相同的索引键，会出现锁冲突。
		- 3、不同事务可以使用不同的索引锁定不同的行
		- 4、主键、唯一、普通索引都是使用行锁(InnoDB)
		- 5、条件中使用索引字段，不一定用索引检索数据。是否使用索引检查数据由MySQL通过判断不同执行计划的代价来决定。如果认为全表扫描的效率更高，就不会使用索引。

	- 分析锁冲突时，检查SQL的执行计划(explain查看)，确认是否使用了索引

- 子主题 5

### 主从同步(复制)

- 定义

	- 将数据从一个数据库服务器复制到其他服务器上
	- 主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这
些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。

- 原理

	- 定义

		- 首先主库发送更新事件到从库；然后从库读取更新记录，并执行更新记录；最后使得从库的内容与主库保持一致
		- slave服务器会在一定时间间隔内对master的binlog二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/O Thread请求master二进制事件。

	- 流程

		- 1、主库的更新事件(update、insert、delete)被写到binlog
		- 2、从库发起连接，连接到主库(让从库知道二进制日志的起点位置)
		- 3、主库创建一个binlog dump thread线程，把binlog的内容发送到从库
		- 4、从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log
		- 5、还会创建一个SQL线程，从relay log里面读取内容，从ExecMasterLog_Pos(Position)位置开始执行读取到的更新事件，将更新内容写入到slave的db

- 注意事项

	- 1、在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）
	- 2、复制是异步进行的

		- 所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器

	- 3、通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表

- 为什么要主从同步？

	- 1、读写分离，提高数据库的并发能力
	- 2、数据备份，保证数据的安全
	- 3、在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能

- 什么是读写分离？

	- 一个主库用于写数据，多个从库完成读数据的操作

### 

### 

### 日志

- 分类

	- bin log

		- 定义

			- 二进制日志
			- 记录MySQL数据库执行修改(DDL和DML)的所有操作，不会记录select和show语句，用于恢复和同步数据。
			- 数据库级别

		- 日志格式

			- statement

				- 基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL

			- row

				- 基于行的日志记录，记录的是每一行的数据变更。（默认）

			- mixed

				- 混合了statement和row两种格式，默认采用statement，可以转为row

		- 作用

			- 1、 灾难时的数据恢复
			- 2、 MySQL的主从复制

		- 操作

			- show variables like '%log_bin%'  

				- 查看相关参数

			- show variables like '%binlog_expire_logs_seconds%

				- 二进制日志过期时间

			- mysqlbinlog [ 参数选项 ] logfilename

				- 查看二进制文件

			- reset master

				- 删除全部 binlog 日志，删除之后，日志编号，将从 binlog.000001重新开始

			- purge master logs to 'binlog.*'

				- 删除 * 编号之前的所有日志

			- purge master logs before 'yyyy-mm-dd hh24:mi:ss'

				- 删除日志为 "" 之前产生的所有日志

	- redo log

		- 定义

			- 重做日志(物理)
			- 记录的是数据库中每个页的修改，而不是某一行或某几行修改成怎么样，可以用来恢复提交后的数据页，并且只能恢复至最后一次提交的位置。
			- InnoDB级别；记录InnoDB存储引擎的事务日志，不管事务是否提交都会记录，用于数据恢复。通过redo log可恢复到数据故障前的状态。

		- 组成

			- 重做日志缓冲（redo log buffer）
			- 重做日志文件（redo log file）

		- 实现持久性

			- 1、事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中
			- 2、过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性

		- 写入机制(日志刷新策略)

			- innodb_flush_log_at_tx_commit

				- 0

					- 每秒提交 redo buffer -> os cache ->disk 可能丢失一秒内的事务数据

				- 1(默认)

					- 每次事务提交执行 redo buffer ->os cache ->disk 性能较差

				- 2

					- 每次事务提交 redo buffer->os cache ,然后由后台Master线程每隔1s进行刷盘

	- undo log

		- 定义

			- 回滚日志(逻辑)
			- 反向记录，记录的是的是数据的逻辑变化(delete->insert)，用于数据的撤回操作
			- update、delete、insert

		- 作用

			- 1、提供回滚，实现事务原子性
			- 2、实现mvcc机制：undo log中保存了未提交之前版本数据，所以可以作为旧版本数据的快照以便其他事务进行读取

		- 注意事项

			- 1、undo log在事务执行时产生，事务提交时，并不会立即删除undo log(MVCC会使用)
			- 2、undo log采用段的方式进行管理和记录，内部包含1024个undo log segment
			- 3、insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除
			- 4、update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除
			- 5、假如一个事务中一条记录被多次修改，undo log只会记录原始版本的一条数据

	- slow query log

		- 定义

			- 慢查询日志用于记录在mysql执行过程超过指定时间的查询语句（默认10s)
			- 默认不会记录管理语句，也不会记录不使用索引进行查找的查询

		- 操作

			- /etc/my.cnf

				- slow_query_log=1

					- 开启慢查询

				- long_query_time=2

					- 执行时间参数

				- log_slow_admin_statements =1

					- 记录执行较慢的管理语句

				- log_queries_not_using_indexes = 1

					- 记录执行较慢的未使用索引的语句

		- 作用

			- 定位出执行效率比较低的SQL，从而有针对性的进行优化

	- relay log(中继日志)

		- 和bin log具有相同的格式，主从复制流程页使用了relay log,其主要作用起到一个中转作用。

	- general query log

		- 定义

			- 一般查询日志用来记录用户的所有操作，包括客户端何时连接的服务器、客户端发送的所有sql以及其他等事情(默认关闭)。
			- ddl+dml+select+show

		- 操作

			- general_log=1

				- 开启查询日志

			- general_log_file=mysql_query.log

				- 修改日志名称

	- error log

		- 定义

			- 记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息

		- 操作

			- show variables like '%log_error%';     -- 查看日志位置

- 日志文件刷新策略

	- 日志文件undo log和redo log不是直接写入到磁盘中,而是写入log buffer,然后等待合适的时机同步到OS buffer,然后由操作系统决定刷新到磁盘的时间。
	- innodb_flush_log_at_tx_commit

		- 0

			- 每秒提交 redo buffer -> os cache ->disk 可能丢失一秒内的事务数据

		- 1(默认)

			- 每次事务提交执行 redo buffer ->os cache ->disk 性能较差

		- 2

			- 每次事务提交 redo buffer->os cache ,然后由后台Master线程每隔1s进行刷盘

- bin log和redo log的区别？

	- 1、bin log记录所有日志记录，包括InnoDB、MyISAM；redo log只记录InnoDB自身的事务日志。
	- 2、bin log只在事务提交前提前写入到磁盘，一个事务只写一次；redo log在事务进行中不断写入磁盘。
	- 3、bin log是逻辑日志，记录的是SQL语句的原始逻辑；redo log是物理日志，记录的是在某个数据页做了什么修改。
	- 4、bin log采用追加的方式写入，redo log采用循环写入的方式写入
	- 5、bin log 用于时间点恢复数据(point-in-time-recovery),保证服务器可以基于时间点恢复数据以及主从复制redo log 用于碰撞恢复(crash recovery),保证mysql宕机不会影响持久性。

### MySQL架构

- Server层

	- 通过api与存储引擎进行通信
	- 分类

		- 连接器

			- 当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验，通过TCP握手获取登录信息后验证权限, 以及连接的管理

		- 查询缓存

			- 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作

		- 分析器

			- 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。

		- 优化器

			- 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。

		- 执行器

			- 先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。

- 存储引擎层

	- 主要负责数据的存储和读取
	- 服务器通过API与存储引擎进行通信

- 数据存储层

	- 主要是将数据存储在运行于裸设备的文件系统之上，并完成于存储引擎的交互。

### 分库分表

- 定义

	- 数据量达到1000w或100G后，优化索引、添加从库提升数据库性能不明显
	- 减少数据的负担，缩短查询的时间

- 方式

	- 垂直划分

		- 表的记录并不多，但是字段却很长，表占用空间很大，检索表的时候需要执行大量的IO，严重降低了性能
		- 划分规则

			- 根据业务进行划分，拆分的表为一对一的关系
			- 例如商品基本信息和描述，可以从商品列表和商品详情页中划分出来

		- 优缺点

			- 查询时减少I/O次数
			- 主键冗余，需要管理冗余列
			- 引起JOIN操作
			- 依然存在单表数据量过大

	- 水平划分

		- 表的记录过多，但记录之间具有一定的联系
		- 划分规则

			- 根据一定规则，例如时间或id序列值等进行数据的拆分
			- 例如根据年份拆分不同的数据库

		- 优缺点

			- 减小的单表的数据量
			- join性能差
			- 分片事务一致性难以解决

### 分区表

- 定义

	- 独立的逻辑表，底层由多个物理字表组成
	- 当查询条件的数据分布在某一个分区的时候，查询引擎只会去某一个分区查询，而不是遍历整个表。在管理层面，如果需要删除某一个分区的数据，只需要删除对应的分区即可.

- 限制

	- 一个表最多只能有1024个分区
	- 分区表达式必须是整数，或者是返回整数的表达式
	- 分区表中无法使用外键约束
	- 如果分区字段中有主见或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来

- 类型

	- 范围(range)分区

		- 每个分区存储落在某个范围的记录，分区表达式可以是列，也可以是包含列的表达式
		- 例如可以将每年的数据放在不同的分区
		- /var/lib/mysql/data/可以找到对应的数据文件，每个分区表都有一个使用#分隔命名的表文件
		- create table sales(
    order_date DATETIME not null,
    -- Other columns omitted
)ENGINE=InnoDB PARTITION BY RANGE(YEAR(order_date))(
    PARTITION P_2017 VALUES LESS THAN(2017),
    PARTITION P_2018 VALUES LESS THAN(2018),
    PARTITION P_2019 VALUES LESS THAN(2019),
    PARTITION P_catchall VALUES LESS THAN MAXVALUE
);

	- list分区

		- 类似于按range分区，区别在于list分区是基于列值匹配一个离散值集合中的某个值来进行选择
		- 分区字段必须已知，插入的字段在分区时枚举值中才能插入
		- 
create table test_list_partiotion
   (
       id int auto_increment,
       data_type tinyint,
       primary key(id,data_type)
   )partition by list(data_type)
   (
       partition p0 values in (0,1,2,3,4,5,6),
       partition p1 values in (7,8,9,10,11,12),
       partition p2 values in (13,14,15,16,17)
   );

	- hash分区

		- 基于用户定义的表达式的返回值来进行选择的分区
		- 可以将数据均匀地分布到预先定义的分区中
		- create table test_hash_partiotion
   (
       id int auto_increment,
       create_date datetime,
       primary key(id,create_date)
    )partition by hash(year(create_date)) partitions 10;

- 可能产生的问题

	- 打开和锁住所有底层表的成本可能很高

		- 当查询访问分区表时，MySQL 需要打开并锁住所有的底层表，这个操作在分区过滤之前发生，所以无法通过分区过滤来降低此开销，会影响到查询速度。可以通过批量操作来降低此类开销，比如批量插入、LOAD DATA INFILE和一次删除多行数据。

	- 维护分区的成本可能很高

		- 例如重组分区，会先创建一个临时分区，然后将数据复制到其中，最后再删除原分区.

	- 所有分区必须使用相同的存储引擎

		- 有时候一个存储引擎并不能满足所有需求

### 大表怎么优化

- 限定数据的范围

	- 控制查询的数据的时间访问等

- 读写分离

	- 拆分数据库，主写从读

- 分库分表

	- 垂直拆分，水平拆分

### SQL语句执行流程

- select

	- 1.检查权限(操作数据库、操作表等)，无权限返回错误
	- 2.查询缓存
	- 3.词法分析和语法分析

		- 提取表名、查询条件，检查语法是否有错误；生成解析树

	- 4.查询优化器生成执行计划(重写查询、决定表的读写顺序以及选择合适的索引等)

		- 选择执行效率最好的方案进行

	- 5.校验权限，有权限就调用数据库引擎接口

		- 查询执行引擎执行 SQL 语句，此时查询执行引擎会根据 SQL 语句中表的存储引擎类型，以及对应的 API 接口与底层存储引擎缓存或者物理文件的交互情况，得到查询结果，由MySQL Server 过滤后将查询结果缓存并返回给客户端。
		- 若开启了 Query Cache，这时也会将SQL 语句和结果完整地保存到 Query Cache 中，以后若有相同的 SQL 语句执行则直接返回结果

- update

	- 1.查询到这条记录，返回查询结果
	- 2.对查询结果相关数据进行更新，然后调用引擎接口，写入更新数据；InnoDB将数据保存到内存中，同时记录redo log，为prepare状态。
	- 3.执行器收到通知后记录bin log，然后调用引擎接口，提交redo log为commit状态
	- 4.更新完成
	- 为什么redo log进入prepare状态？

		- 1、update是一个更新操作，由于是B+树索引，相对其他的结构，新增和删除操作，时间复杂度很高。后续的一系列操作稍后一起做，这样就极大的提高了写入性能。
		- 2、假设redo log直接提交，然后写bin log，如果写完redo log后机器宕机，bin log没有写入这条记录，当机器通过redo log恢复数据时，bin log中没有记录该数据，后续备份时会丢失这条数据，主从同步也会丢失这条数据。

### exists和in的区别

- exists

	- 用于对外表记录做筛选。
	- 对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时(有即可)，条件就为真，返回当前loop到的这条记录；反之同理。
	- select * from user where exists (select * from user where user_id = 0);

- in

	- in查询就是先将子查询条件的记录全都查出来，放到一个临时表中，然后遍历临时表，将临时表的每一行，代入到外查询中查找
	- where id in(select id from B)

- 区别

	- // in查询的子条件返回结果必须只有一个字段；exists没有限制
	- in只查询一次；exists看情况
	- in适合于外表大而内表小；exists适合于外表小而内表大
	- 子查询的表比较大的时候，使用exists可以有效减少总的循环次数来提升速度；当外查询的表比较大的时候，使用in可以有效减少对外查询表循环遍历来提升速度。

### int(10)和char(10)的区别

- int(10)中的10表示的是显示数据的长度，而char(10)表示的是存储数据的长度

### truncate、delete与drop区别

- 相同点

	- truncate和不带where子句的delete、drop都会删除表内的数据
	- drop、truncate都是DDL语句(数据定义语言)执行后会自动提交
	- delete是DML语句(数据操作语言)

- 不同点

	- truncate 和 delete 只删除数据不删除表的结构；drop 语句将删除表的结构被依赖的约束、触发器、索引
	- 执行速度: drop > truncate > delete

- truncate删除数据后，auto_increment从0开始；delete从断电开始

### having和where区别

- 作用的对象不同

	- where字句作用于表和视图；having作用于组

- 过滤时机不同

	- where在数据分组前过滤，不参与分组；having数据分组后过滤(having...group by)

- 判断条件不同

	- where不能对聚合函数进行判断，而having可以

- 注意事项

	- having在查询返回结果集以后，对查询结果进行的过滤操作;where是在结果返回之前起作用的;
	- 执行顺序：where > 聚合函数 > having
	- 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义

### 共享锁和排他锁

- 定义

	- select的读取锁定方式

- 分类

	- 共享锁(读/S锁)

		- 定义

			- 共享锁就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有

		- 应用场景

			- 共享 (S) 用于不更改或不更新数据的操作（只读操作），如SELECT 语句
			- 如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据，直到该数据对象上的所有共享锁都被释放

		- 加锁方式

			- SELECT ... LOCK IN SHARE MODE

	- 排他锁(写/X锁)

		- 定义

			- 一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁

		- 应用场景

			- 用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新
			- 如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据

		- 加锁方式

			- SELECT ... FOR UPDATE

### 快照读和当前读

- 快照读

	- 读取的是记录数据的可见版本（ReadView，可能是过期的数据），不用加锁
	- 快照读情况下，Innodb通过mvcc机制避免了幻读，因为读取的是可见版本，不存在读取更高版本的记录；并且没有记录的添加
	- 不加锁的select

- 当前读

	- 取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录。
	- 当前读情况下，可能会产生幻读，因为每次读取的都是最新数据，如果两次查询中间有数据插入，产生幻读----间隙锁
	- update、insert、delete、select....for update、select....lock in share mode(共享锁)

### 快照读和当前读

### 快照读和当前读

### 乐观锁和悲观锁

- 定义

	- 数据库中的并发控制是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观锁和悲观锁是并发控制主要采用的技术手段。
	- 乐观锁(mvcc)

		- 假设不会发生并发冲突，只在提交操作时检查是否数据是否被修改过
		- 实现方式

			- 版本号机制

				- 给表增加version字段，在修改提交之前检查version与原来取到的version值是否相等，若相等，表示数据没有被修改，可以更新，否则，数据为脏数据，不能更新。

			- CAS 算法 

				- 一种非阻塞式的同步方式
				- ”比较并交换“，是一种轻量级锁
				- 定义

					- 线程在读取数据是不进行加锁，在准备修改数据时，先去查询原值，操作的时候比较原值是否被修改，若未被其他线程修改则写入数据，若已经被修改，就要重新执行读取流程。

	- 悲观锁(行锁)

		- 假定会发生并发冲突，在查询完数据的时候就把事务锁起来，直到提交事务。
		- 实现方式

			- 使用数据库的锁机制
			- 行锁，表锁，读写锁

### processlist

- show processlist 或 show full processlist 可以查看当前 MySQL 是否有压力，正在运行的SQL，有没有慢SQL正在执行
- 参数

	- id：线程ID，可以用kill id杀死某个线程
db：数据库名称
user：数据库用户
host：数据库实例的IP
command：当前执行的命令，比如Sleep，Query，Connect等
time：消耗时间，单位秒
state：执行状态，主要有以下状态：
Sleep，线程正在等待客户端发送新的请求
Locked，线程正在等待锁
Sending data，正在处理SELECT查询的记录，同时把结果发送给客户端
Kill，正在执行kill语句，杀死指定线程
Connect，一个从节点连上了主节点
Quit，线程正在退出
Sorting for group，正在为GROUP BY做 排序
Sorting for order，正在为ORDER BY做 排序
info：正在执行的SQL语句

### delete、truncate、drop的区别

- delete

	- 1、只删除数据不删除表的结构，会走事务，执行时会触发trigger
	- 2、在 InnoDB 中，DELETE其实并不会真的把数据删除,只是把删除的数据行设置为不可见
	- 3、DELETE执行时，会先将所删除数据缓存到rollback segement中，事务commit之后生效;
	- 4、InnoDB：不带where时释放磁盘空间，带where时不会释放
	- 5、delete 操作是一行一行执行删除的，并且同时将该行的的删除操作日志记录在redo和undo表空间中
	- 6、auto_increment不变，除非delete后重启mysql

- truncate

	- 1、只删除数据不走事务，原数据不放到 rollback segment 中，操作不触发 trigger
	- 2、立刻释放磁盘空间 
	- 3、truncate能够快速清空一个表。并且重置auto_increment的值
	- 4、truncate相当于删除整张表后再创建表

- drop

	- 1、删除整张表(结构和数据)，表的结构被依赖的约束、触发器、索引等
	- 2、依赖于该表的存储过程/函数将保留,但是变为 invalid 状态

### Mysql缓存机制

- 缓存数据形式key-value,key为查询SQL
- 需要在my.cnf中配置query_cache_type参数（0,1,2）,这个默认在5.7后版本是关闭的
- 操作

	- 查看缓存运行状态

		-  show status like ‘%Qcache%’

	- 查询缓存

		- show variables like ‘%query_cache%’

	- 按需使用缓存

		- select SQL_CACHE * from test

### char和varchar的区别？

- 1、char长度固定，varchar长度可变
- 2、效率不同 

	- char每次修改的数据长度相同，效率更高

- 3、存储不同

	- char最大长度是255字符，varchar最大长度是65535个字节

### change和modify的区别？

- change可以修改字段名的字段类型；modify只能修改字段类型
- 都是DDL语言

### null值不参与聚合函数的计算

### count(*)、count(字段)、count(1)的区别？

### DQL执行顺序

- ![image-20220804113539983](https://gitee.com/curit/test-project/raw/master/src/main/resources/image/md/202208041135526.png)

