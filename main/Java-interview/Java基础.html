<!doctype html>
<html style='font-size:18px !important'>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<link href="https://gitee.com/curit/test-project/raw/master/src/main/resources/CuriT-icon/CuriT-transparent-T.png" rel="shortcut icon">
<style>
#O-switch, .typora-export-sidebar {
    -moz-user-select: none; 
    -webkit-user-select: none; 
    -ms-user-select: none; 
    -khtml-user-select: none; 
    user-select: none;
}
</style>
<link href='https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap' rel='stylesheet' type='text/css' /><link href='https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@500&display=swap' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; --title-bar-height:20px; }
.mac-os-11 { --title-bar-height:28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
span.cm-underlined { text-decoration: underline; }
span.cm-strikethrough { text-decoration: line-through; }
.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }
.cm-tw-deleted { text-decoration: line-through; }
.cm-tw-header5 { font-weight: 700; }
.cm-tw-listitem:first-child { padding-left: 10px; }
.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }
.cm-tw-underline { text-decoration: underline; }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


/* 基于 rainbow 主题 */
/*
fonts initalization
*/
@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap);
@import url(https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@500&display=swap);

@page {
	size: A4;
	margin: 8mm 0mm;
}

/*
root variables including colors, font-familys and a shadow style
*/
:root {
	--bg-color: #f3f2ee;
	--font--family: "宋体", "思源黑体 CN", "微软雅黑";
	--monospace-font: "Source Code Pro Regular", "Source Code Pro", monospace;
	--font--family-h1: "方正楷体_GBK", "微软雅黑";
	--font--family-h2: "华康手札体W5P", "微软雅黑";

	--color--h2--quote: #2d7d59;
	/* 二级标题背景颜色、引用侧边颜色*/
	--color--quote--backgroudn: rgba(66, 185, 131, 0.1);
	/*引用背景颜色*/
	--color--h--focus: #ff5d52;
	/* 标题点击后的前缀提示颜色 */

	--color--inlinecode--font: #D83B64;
	/*行内代码字体颜色*/
	--color--inlinecode--background: #f9f2f4;
	/*行内代码背景2颜色*/
	--color--url: #659ddc;
	/*超链接字体颜色*/
	--color--url--focus: #f60;
	/*选中的超链接后的填充颜色*/
	--color--url--focus--font: #ffffffe6;
	/*选中的超链接后的字体颜色*/
	--color--highlight: #ffff00;
	/*高亮颜色*/
	--del-color: rgb(151, 151, 151);
	/*删除线颜色*/
	--italic-color: gray;
	/*斜体颜色*/
	--strong-color: brown;
	/*粗体颜色*/
	--underline-color: #f00;
	/*下划线颜色*/
	--ol-color: #81accf;
	/* 有序列表前缀颜色 */
	--olfore-color: #fff;
	/* 有序列表字体颜色 */

	--h-border-color: rgb(255, 191, 191);
	--h-bg-color: rgb(255, 232, 232);
	--table-border-color: rgb(255, 235, 211);
	--th-bg-color: rgb(255, 243, 228);
	--tr-bg-color: rgb(255, 249, 242);
	--tr-hover-bg-color: rgb(254, 255, 230);
	--code-bg-color: rgb(247, 247, 247);

	--selection-bg-color: rgb(235, 227, 255);
	--block-shadow: 0.15rem 0.15rem 0.5rem rgb(150, 150, 150);

	--focus-color: #ff5d52; /* 点击某些元素（如标题）显示的颜色（偏红） */
	--ulol-color: #81accf; /* 有序无序列表前缀颜色（灰色） */
    --olfore-color: #fff; /* 有序列表字体颜色（白色） */
    --taskborder-color: #81accf; /* 任务列表边框色（红色） */
    --taskfocus-color: #81accf; /* 任务列表选中填充色（绿色） */

}

html {
	background-color: #f3f2ee;
	font-size: 16px;
}

body {
	background-color: #f3f2ee;
}


#write {
	font-family: var(--font--family);
	max-width: 60rem;
	padding-left: 2rem;
	padding-right: 2rem;
}

/*
yaml header settings
*/
#write pre.md-meta-block {
	font-family: var(--monospace-font);
	font-size: 1rem;
	text-align: left;
	padding: 0.6rem;
	color: rgb(134, 134, 134);
	background-color: var(--code-bg-color);
	border-radius: 0.4rem;
}

/*
headers settings
标题
*/
#write h1 {
	font-size: 1.75rem;
	text-align: center;
	font-family: var(--font--family-h1);
}

#write h2 {
	font-size: 1.5rem;
	border-bottom: 2px solid var(--color--h2--quote);
	font-family: var(--font--family-h2);
}

#write h2 span {
	display: inline-block;
	font-weight: bold;
	background: var(--color--h2--quote);
	color: #ffffff;
	padding: 3px 10px 1px;
	border-top-right-radius: 3px;
	border-top-left-radius: 3px;
	margin-right: 3px;
}

#write h2:after {
	display: inline-block;
	content: "";
	vertical-align: bottom;
	border-bottom: 36px solid #efebe9;
	border-right: 20px solid transparent;
}

h3 {
	font-size: 1.3em;
	line-height: 1.43;
	margin: 1.6em auto 1.2em;
	padding-left: 8px;
	border-left: 4px solid var(--color--h2--quote);
}

#write>h3.md-focus {
	border-color: var(--color--h--focus);
}

#write h4 {
	font-size: 1.15rem;
}

#write h5 {
	font-size: 1rem;
}

#write h6 {
	font-size: 1rem;
}

/* 标题点击后的前缀提示图标 */
#write>h3.md-focus:before {
	width: auto;
	height: auto;
	background-color: var(--color--h--focus);
	color: #ffffff;
}

#write>h4.md-focus:before {
	width: auto;
	height: auto;
	background-color: #ff5d52;
	color: #ffffff;
	margin-top: -1px;
}

#write h5.md-focus:before,
#write h6.md-focus:before {
	margin-top: 6px;
	color: #ff5d52;
	font-size: 0.4rem;
}

/*
tables settings
表格
*/
#write table {
	display: table;
	text-align: left;
}

#write tbody {
	border: 0;
}

#write table tr {
	border: 0;
	border-top: 1px solid #ccc;
	background-color: white;
}

#write table tr:nth-child(2n) {
	background-color: #F8F8F8;
}

#write table tr th,
#write table tr td {
	font-size: 16px;
	border: 1px solid #ccc;
	padding: 5px 10px;
	text-align: left;
}

#write table tr th {
	font-weight: bold;
	background-color: #f0f0f0;
}

/*
checkboxes settings
任务列表
*/
.md-task-list-item>input {
    margin-left: -1.3em;
    margin-top: 0.4rem;
    -webkit-appearance: none;
}

/* 任务列表未选中 */
#write .task-list-item input[type="checkbox"]::before,
#write input[type="checkbox"]:checked::before {
	content: "";
	display: inline-block;

	/*圆形框*/
	border-radius: 1.1rem;

	/* 方形框 */
	/* border-radius: 0.1rem; */
	vertical-align: middle;
	border: 1.2px solid #81accf;
	background-color: #ffffff;
	width: 1.1rem;
	height: 1.1rem;
	margin-left: -1px;
	margin-right: 0.1rem;
	margin-top: -0.19rem;
}

/* 任务列表选中 */
#write .task-list-item input[type="checkbox"]:checked::before {
	padding-left: 0.125em;
	padding-top: 0em;
	content: '✔';
	color: white;
	background-color: #81accf;
	font-size: 0.8rem;
	line-height: 0.95rem;
	margin-left: -1px;
	margin-right: 0.1rem;
	margin-top: -0.19rem;
	transition: background-color 200ms ease-in-out;
}

#write .task-list-item input[type="checkbox"]:checked+p {
	text-decoration: line-through;
	color: var(--del-color);
}

#write input[type='checkbox']:hover::before {
	transition: all 0.2s;
	background-color: rgb(228, 228, 228);
}

/** 有序、无序列表 **/
/* 有序列表在加入换行后重新计数了，故注释了，待修复 */
/* #write ol li,
#write .ol .li, */
#write ul li,
#write .ul .li {
	list-style-type: none;
}

#write ul>li:not(.tab):before,
#write .ul>.li:not(.tab):before {
	margin-left: -18px;
	margin-top: 7px;
	width: .62em;
	height: .62em;
	border: .1em solid var(--ulol-color);

	border-radius: .31em;
	background: 0 0;
	content: '';
	line-height: .42em;
}

/* #write ol li:before,
#write .ol .li:before, */
#write ul li:before,
#write .ul .li:before {
	position: absolute;
	background: var(--ulol-color);
	color: var(--olfore-color);
	cursor: pointer;
	-webkit-transition: all .3s ease-out;
	-moz-transition: all .3s ease-out;
	-o-transition: all .3s ease-out;
	-ms-transition: all .3s ease-out;
	transition: all .3s ease-out;
}

/* #write ol li:first-child,
#write .ol .li:first-child {
	counter-reset: li;
} */

/* #write ol>li:before,
#write .ol>.li:before {
	margin-top: 3.8px;
	margin-left: -21px;
	width: 1.65em;
	height: 1.65em;
	border-radius: 0.825em;
	content: counter(li);
	counter-increment: li;
	text-align: center;
	font-size: .65em;
	line-height: 1.7em;
} */

/* 列表子项上下间隔调整 */
/* #write ol li *,
#write .ol .li *  */
#write ul li *,
#write .ul .li * {
	margin-top: 0px;
	margin-bottom: 0px;
}

/* 列表上下间隔调整 */

/* #write ol li,
#write .ol .li, */
#write ul li,
#write .ul .li {
	margin-top: 7px;
	margin-bottom: 7px;
}


/*
blockquotes settings
引用
*/
#write blockquote {
	color: #7e7a7a;
	border-left: 0.25rem solid var(--color--h2--quote);
	background: var(--color--quote--backgroudn);
	padding: 0.25rem 0.5rem;
	border-radius: 0.25rem;
}

/* 引用中的彩虹 */
#write blockquote::before {
	display: block;
	height: 2rem;
	width: 1.5rem;
	content: "🌈";
	font-size: 1.2rem;
}

/* 引用内单行代码 */
#write blockquote code {
	background-color: transparent;
}

/*
horizontal rules settings
*/
#write hr {
	margin-top: 2rem;
	margin-bottom: 2rem;
	background-color: rgb(226, 226, 226);
	height: 0.13rem;
	border: 0;
}


/*
code blocks settings
代码块
*/
#write .md-fences {
	font-family: var(--monospace-font);
	font-size: 1rem;
	padding: 0.6rem;
	background-color: var(--code-bg-color);
	border-radius: 0.4rem;
	box-shadow: var(--block-shadow);
}

#write .cm-s-inner .CodeMirror-gutters {
	border: none;
}

#write .cm-s-inner .CodeMirror-linenumber {
	color: rgb(212, 212, 212);
}

#write .cm-s-inner .cm-keyword {
	color: rgb(204, 35, 35);
}

#write .cm-s-inner .cm-number {
	color: rgb(27, 57, 226);
}

#write .cm-s-inner .cm-def {
	color: rgb(146, 50, 255);
}

#write .cm-s-inner .cm-operator {
	color: rgb(204, 35, 35);
}

#write .cm-s-inner .cm-variable2 {
	color: rgb(38, 129, 219);
}

#write .cm-s-inner .cm-variable3 {
	color: rgb(204, 35, 35);
}

#write .cm-s-inner .cm-comment {
	color: rgb(18, 129, 18);
}

#write .cm-s-inner .cm-string {
	color: rgb(18, 129, 18);
}

#write .cm-s-inner .cm-builtin {
	color: rgb(218, 135, 12);
}

#write .cm-tag {
	color: rgb(139, 10, 10);
}

/*
formulas settings
*/
#write mjx-container {
	font-size: 1.1rem;
}

/*
tooltips settings
*/
#write .code-tooltip {
	box-shadow: 0.1rem 0.1rem 0.2rem rgb(150, 150, 150);
	border-radius: 0.2rem;
	margin-top: 0.3rem;
}

/*
selected texts in code blocks settings
*/
#write .CodeMirror-selected,
#write .CodeMirror-selectedtext,
#write .in-text-selection {
	background-color: var(--selection-bg-color) !important;
}
/*
selected texts settings
文本选中后的颜色
*/
#write ::selection {
	background-color: var(--selection-bg-color);
}

/*
diagrams settings
*/
#write pre[lang=’sequence’],
#write pre[lang=’flow’],
#write pre[lang=’mermaid’] {
	background-color: var(--code-bg-color);
	border-radius: 0.4rem;
	box-shadow: var(--block-shadow);
}

/*
inline codes settings
行内代码
*/
#write code {
	font-family: var(--monospace-font);
	padding: 0.05rem 0.12rem;
	color: var(--color--inlinecode--font);
	background-color: var(--color--inlinecode--background);
	border-radius: 0.4rem;
}

/*
urls settings
超链接
*/
#write a {
	color: var(--color--url);
	text-decoration: none;
}

#write a:hover {
	border-radius: 6px;
	border-bottom: 2px solid transparent;
	background-color: var(--color--url--focus);
	color: var(--color--url--focus--font) !important;
	cursor: pointer;
	padding: 2.5px 2.5px;
	font-size: 1rem;
}

/*
images settings
图像
*/
#write img {
	display: block;
	margin: 0 auto;
	border: 0;
	border-radius: 12px;
	box-shadow: var(--block-shadow);
	margin-bottom: 4px;
}

/*
deletes settings
删除线
*/
#write del {
	color: var(--del-color);
}


kbd {
	background-color: rgb(255, 255, 255);
	border-radius: 8px;
	color: black;
	padding: 1px 4px;
	font-family: "微软雅黑";
	font-size: 0.8rem;
	border-top: 1px solid #cfcfcf;
	border-left: 1px solid #cfcfcf;
	border-right: 1px solid #cfcfcf;
	border-bottom: 3px solid #cfcfcf;
}

/* 斜体 */
em {
	font-style: normal;
	color: var(--italic-color);
}

/* 粗体 */
strong {
	background-color: inherit;
	color: var(--strong-color);
}

/* 下划线 */
u {
	background-color: inherit;
	color: inherit;
	text-decoration: none;
	border-bottom: 2px solid var(--underline-color);
	padding-bottom: 1px;
}

/* 高亮 */
mark {
	color: black;
	font-weight: normal;
	padding: 1px 5px 2px;
	border-radius: 2px;
	background-color: var(--color--highlight) !important;
}

/* sidebar	侧边栏 */
#typora-sidebar {
	background-color: #f3f2ee;
	/* 分割线 */
	border-right: 1px dashed #C0C0C0;
}

#typora-sidebar #sidebar-loading-template.file-list-item {
	border-bottom: transparent !important;
	background-color: rgba(171, 192, 208, 0.1);
}

#typora-sidebar .info-panel-tab-wrapper .info-panel-tab:hover {
	color: inherit;
}

#typora-sidebar .info-panel-tab-wrapper .info-panel-tab .info-panel-tab-border {
	background-color: #2f845e;
	border-radius: 4px;
}

#typora-sidebar .sidebar-osx-tab .sidebar-tabs {
	border-bottom-color: transparent;
}

#typora-sidebar #sidebar-content .file-list-item {
	border-bottom: 1px solid #eee;
}

#typora-sidebar #sidebar-content .file-list-item.active {
	background-color: rgba(66, 185, 131, 0.1);
	border-left: 4px solid #2f845e;
}

#typora-sidebar #sidebar-content .ty-sidebar-search-panel {
	border-bottom: 1px solid #eee;
}

#typora-sidebar #sidebar-content .ty-sidebar-search-panel .searchpanel-search-option-btn {
	background-color: #fff;
}

#typora-sidebar #sidebar-content .sidebar-content-content .file-node-content {
	line-height: 1.375rem;
	font-size: 1rem;
	color: #282c34 !important;
}

#typora-sidebar #sidebar-content .sidebar-content-content .file-tree-node:not(.file-node-root):hover>.file-node-background {
	border-left: 4px solid #2f845e;
	background-color: rgba(66, 185, 131, 0.1);
}

#typora-sidebar #sidebar-content .sidebar-content-content .file-tree-node.active>.file-node-background {
	border-color: #2f845e;
	background-color: rgba(66, 185, 131, 0.1);
}

#typora-sidebar #sidebar-content .sidebar-content-content #file-library-list-children .file-library-file-node:hover {
	border-left: 4px solid #2f845e;
	background-color: rgba(66, 185, 131, 0.1);
}

#typora-sidebar #sidebar-content #outline-content .no-collapse-outline .outline-item {
	line-height: 1.375rem;
	font-size: 1rem;
}

#typora-sidebar #sidebar-content #outline-content .outline-expander:before {
	color: inherit;
	font-size: 14px;
	top: auto;
	content: "\f0da";
	font-family: FontAwesome;
}

#typora-sidebar #sidebar-content #outline-content .outline-expander:hover:before,
#typora-sidebar #sidebar-content #outline-content .outline-item-open>.outline-item>.outline-expander:before {
	content: "\f0d7";
}

#typora-sidebar #sidebar-content #outline-content .outline-item:hover {
	background-color: #bac6e9 !important;
}

#typora-sidebar #ty-sidebar-footer {
	border-top: 1px solid #eee;
}

#typora-sidebar #ty-sidebar-footer .sidebar-footer-item:hover {
	background-color: #bac6e9 !important;
}

#typora-sidebar #ty-sidebar-footer #sidebar-files-menu {
	-webkit-box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.16), 0 2px 10px 0 rgba(0, 0, 0, 0.12);
	box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.16), 0 2px 10px 0 rgba(0, 0, 0, 0.12);
}


/* mac 风格 */
#write pre.md-fences {
	padding: 1rem 0.5rem 1rem;
	display: block;
	-webkit-overflow-scrolling: touch;
	/* box-shadow: 0 0 6px 2px rgba(151, 151, 151, 0.9); */
	/* border-top: rgb(51, 51, 51) solid 24px; */
	border-top: rgb(244, 244, 244) solid 24px;
	background-color: rgb(244, 244, 244);
}

pre.md-fences::before {
	content: '';
	background: #fc625d;
	box-shadow: 23px 0 #fdbc40, 45px 0 #35cd4b;
	border-radius: 50%;
	margin-top: -1.73rem;
	position: absolute;
	left: 15px;
	height: 12px;
	width: 12px;
}


/** 图片 **/

/* 图片自动编号 */
#write {
    counter-reset: imgNum;
}

#write p>.md-image:after {
    counter-increment: imgNum;
    content: "图 " counter(imgNum) attr(alt) !important;
    text-align: center;
    width: 100%;
    display: inline-block;
    margin-top: 8px !important;
    font-size: small;
	font-family:"华康手札体W5P";
    font-size:1rem;
	color:gray;
}


</style><title>Java</title>
</head>
<body class='typora-export os-windows typora-export-show-outline typora-export-collapse-outline'><div class='typora-export-content'>
<div class="typora-export-sidebar"><div class="outline-content"><li class="outline-item-wrapper outline-h1 outline-item-open"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java">Java</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java基础">Java基础</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#与equals的区别">==与equals的区别？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java语言的特点">Java语言的特点</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#面向对象和面向过程的区别">面向对象和面向过程的区别</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#八种基本数据类型的大小以及他们的封装类">八种基本数据类型的大小，以及他们的封装类</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#instanceof-关键字的作用">instanceof 关键字的作用</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java自动装箱与拆箱">Java自动装箱与拆箱</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#重载和重写的区别">重载和重写的区别</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#equals和的区别">equals和==的区别</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#hashcode的作用">Hashcode的作用</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#stringstring-stringbuffer-和-stringbuilder-的区别是什么">String、String StringBuffer 和 StringBuilder 的区别是什么？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#arraylist和linkedlist的区别">ArrayList和linkedList的区别</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#hashmap和hashtable的区别">HashMap和HashTable的区别</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#collection包结构与collections的区别">Collection包结构，与Collections的区别</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java的四种引用强弱软虚">Java的四种引用，强弱软虚</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#泛型">泛型</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java创建对象有几种方式">Java创建对象有几种方式？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#解决哈希冲突的方法">解决哈希冲突的方法？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#深拷贝和浅拷贝">深拷贝和浅拷贝</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#final有哪些用法">final有哪些用法?</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#static都有哪些用法">static都有哪些用法?</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#aab与ab有什么区别吗">a=a+b与a+=b有什么区别吗?</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#finally的执行机制">finally的执行机制</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#什么情况下finally不执行">什么情况下finally不执行？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#excption与error包结构">Excption与Error包结构</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#oom你遇到过哪些情况sof你遇到过哪些情况">OOM你遇到过哪些情况，SOF你遇到过哪些情况？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#简述线程程序进程的基本概念以及他们之间关系是什么">简述线程、程序、进程的基本概念。以及他们之间关系是什么?</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#有些字段不想进行序列化">有些字段不想进行序列化？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#说说java-中-io-流">说说Java 中 IO 流</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java反射的作用与原理">Java反射的作用与原理</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#listsetmap三者的区别">List,Set,Map三者的区别？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#object的方法">Object的方法？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#获取一个类class对象的方式有哪些">获取一个类Class对象的方式有哪些？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么arrayslist不安全">为什么ArraysList不安全？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#说说什么是-fail-fast">说说什么是 fail-fast？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#hashmap-中的-key-我们可以使用任何类作为-key-吗">HashMap 中的 key 我们可以使用任何类作为 key 吗？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#hashmap-与-concurrenthashmap-的异同">HashMap 与 ConcurrentHashMap 的异同</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#说说你平时是怎么处理-java-异常的">说说你平时是怎么处理 Java 异常的？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#什么是jdk什么是jre">什么是JDK？什么是JRE?</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么重写equals一定要重写hashcode">为什么重写equals一定要重写hashcode？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#接口和抽象类的区别">接口和抽象类的区别？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#error-和-exception-的区别">Error 和 Exception 的区别?</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#常见的检查异常和非检查异常">常见的检查异常和非检查异常？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#oop">OOP</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#修饰符">修饰符</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#javase">JavaSE</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#多线程">多线程</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#反射">反射</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#注解">注解</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#io流">IO流</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#网络编程">网络编程</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java集合">Java集合</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java8新特性">Java8新特性</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#juc">JUC</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#相关概念">相关概念</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#不集合安全类">不集合安全类</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#callable">Callable</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#三大辅助类">三大辅助类</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#读写锁">读写锁</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#阻塞队列">阻塞队列</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#线程池">线程池</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#jmm">JMM</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#volatile">volatile</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#单例模式">单例模式</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#cas">CAS</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#aba问题">ABA问题</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java锁">Java锁</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#waitsleep的区别">wait/sleep的区别？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#volatile为什么不能保证原子性">volatile为什么不能保证原子性？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#volatile和synchronized区别">volatile和synchronized区别</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#lock-和-synchronized的区别">Lock 和 Synchronized的区别？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#copyonwritearraylist为什么并发安全且性能比vector好">CopyOnWriteArrayList为什么并发安全且性能比Vector好？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#独占锁写锁共享锁读锁">独占锁(写锁)、共享锁(读锁)</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#公平锁和非公平锁">公平锁和非公平锁</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么使用blockingqueue">为什么使用BlockingQueue？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#触发线程池的拒绝策略的时机">触发线程池的拒绝策略的时机？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#线程池用哪个为什么不用executors">线程池用哪个？为什么不用Executors？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#生产中如何设置合理参数">生产中如何设置合理参数？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#线程池的执行原理">线程池的执行原理？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#线程是否越多越好">线程是否越多越好？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#atomicintegergetandincrement的自增--1如何实现">atomicInteger.getAndIncrement()的自增 + 1如何实现？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#synchronized实现原理">synchronized实现原理？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#synchronized早期效率低">synchronized早期效率低？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#对象的内存布局">对象的内存布局</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#锁消除和锁粗化">锁消除和锁粗化</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#synchronized优化锁优化">synchronized优化(锁优化)</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#jvm">JVM</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#定义">定义</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#特点">特点</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#类加载子系统">类加载子系统</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#程序计数器pc">程序计数器(PC)</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#虚拟机栈">虚拟机栈</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#本地方法接口">本地方法接口</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#本地方法栈">本地方法栈</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#堆">堆</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#方法区元空间">方法区(元空间)</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#对象的实例化">对象的实例化</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#执行引擎">执行引擎</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#垃圾回收">垃圾回收</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#子主题-29">子主题 29</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#类发生初始化的时机">类发生初始化的时机？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#加载class文件的方式">加载class文件的方式？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么要把符号引用转为直接引用">为什么要把符号引用转为直接引用？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么要自定义类加载器">为什么要自定义类加载器？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#java堆heap跟栈stack的区别">Java堆(Heap)跟栈(Stack)的区别？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#栈可能出现的问题">栈可能出现的问题？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#举例栈溢出oom的情况">举例栈溢出(OOM)的情况？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#调整栈大小就能保证不出现溢出么">调整栈大小，就能保证不出现溢出么？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#分配的栈内存越大越好么">分配的栈内存越大越好么？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#垃圾回收是否涉及到虚拟机栈">垃圾回收是否涉及到虚拟机栈？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#方法中定义的局部变量是否线程安全">方法中定义的局部变量是否线程安全？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么private修饰的方法无法this调用">为什么private修饰的方法无法this调用？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#静态变量和局部变量的区别">静态变量和局部变量的区别？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#栈顶缓存技术">栈顶缓存技术？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么需要常量池运行时常量池">为什么需要常量池、运行时常量池？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#方法结束的方式">方法结束的方式？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#运行时数据区是否存在error和gc">运行时数据区，是否存在Error和GC？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#什么是stw">什么是STW？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么要把java堆分代不分代就不能正常工作了吗">为什么要把Java堆分代？不分代就不能正常工作了吗？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#堆空间都是共享的吗">堆空间都是共享的吗？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么有tlab">为什么有TLAB？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#堆是分配对象的唯一选择么">堆是分配对象的唯一选择么？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#元空间与永久代的区别">元空间与永久代的区别？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#如何解决oom">如何解决OOM？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#static和static-final的区别">static和static final的区别?</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#hotspot方法区的变化">Hotspot方法区的变化？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么永久代要被元空间替代">为什么永久代要被元空间替代？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#stringtable为什么要调整位置">StringTable为什么要调整位置？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#什么是直接内存">什么是直接内存？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么需要gc">为什么需要gc？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#不要主动调用某个对象的finalize方法应该交给垃圾回收机制调用">不要主动调用某个对象的finalize方法,应该交给垃圾回收机制调用？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#分代算法和分区算法的区别">分代算法和分区算法的区别？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#你开发中使用过weakhashmap吗">你开发中使用过WeakHashMap吗？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#cms为什么不使用标记整理算法">CMS为什么不使用标记整理算法？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#为什么cms是低延迟的">为什么CMS是低延迟的？</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h3 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#g1设置h的原因">G1设置H的原因？</a></div><ul class="outline-children"></ul></li></ul></li></ul></li></div></div><div id='write'  class=''><h1 id='java'><span>Java</span></h1><h2 id='java基础'><span>Java基础</span></h2><h3 id='与equals的区别'><span>==与equals的区别？</span></h3><ul><li><span>1、==比较的是两个变量或实例是不是指向同一个内存空间，equals比较的是两个变量或实例是不是指向同一个内存空间的值是否相同</span></li><li><span>2、Object类的equals默认比较的是内存地址，自定义的实现类需要重写equals才能比较值。</span></li></ul><h3 id='java语言的特点'><span>Java语言的特点</span></h3><ul><li><p><span>1、简单易学、有丰富的类库</span></p></li><li><p><span>2、面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）</span></p></li><li><p><span>3、与平台无关性（JVM是Java跨平台使用的根本）</span></p><ul><li><span>只关心字节码文件</span></li></ul></li><li><p><span>4、可靠安全</span></p></li><li><p><span>5、支持多线程</span></p></li></ul><h3 id='面向对象和面向过程的区别'><span>面向对象和面向过程的区别</span></h3><ul><li><p><span>面向过程</span></p><ul><li><span>是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。</span></li></ul></li><li><p><span>面向对象</span></p><ul><li><span>把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。</span></li><li><span>封装、继承、多态</span></li></ul></li></ul><h3 id='八种基本数据类型的大小以及他们的封装类'><span>八种基本数据类型的大小，以及他们的封装类</span></h3><ul><li><p><span>子主题 1</span></p></li><li><p><span>注意事项</span></p><ul><li><p><span>1、int是基本数据类型，Integer是int的封装类，是引用类型。</span></p></li><li><p><span>2、基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。</span></p></li><li><p><span>3、出boolean类型占了单独使用是4个字节，在数组中又是1个字节</span></p><ul><li><span>32位的处理器（CPU）来说，一次处理数据是32位</span></li></ul></li><li><p><span>4、Java中只有对基本类型变量的赋值和读取是原子操作(i=1)</span></p></li></ul></li><li><p><span>定义的数据范围超出类型的范围，自动转换为最小值</span></p></li></ul><h3 id='instanceof-关键字的作用'><span>instanceof 关键字的作用</span></h3><ul><li><span>用来测试一个对象是否为一个类的实例(对象是否能转换为右边的Class类型)</span></li><li><span>父子类</span></li></ul><h3 id='java自动装箱与拆箱'><span>Java自动装箱与拆箱</span></h3><ul><li><p><span>装箱</span></p><ul><li><p><span>装箱就是自动将基本数据类型转换为包装器类型</span></p><ul><li><span>Integer.valueOf(int)</span></li></ul></li></ul></li><li><p><span>拆箱</span></p><ul><li><p><span>自动将包装器类型转换为基本数据类型</span></p><ul><li><span>Integer.intValue()</span></li></ul></li></ul></li><li><p><span>在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</span></p></li><li><p><span>在某个范围内的整型数值的个数是有限的，而浮点数却不是。</span></p></li></ul><h3 id='重载和重写的区别'><span>重载和重写的区别</span></h3><ul><li><p><span>重写(Override)</span></p><ul><li><span>在子类中把父类本身有的方法重新写一遍。</span></li><li><span>方法名，参数列表，返回类型都相同</span></li></ul></li><li><p><span>重载(OverLoad)</span></p><ul><li><span>在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）</span></li><li><span>返回类型可以不同</span></li></ul></li></ul><h3 id='equals和的区别'><span>equals和==的区别</span></h3><ul><li><p><span>==</span></p><ul><li><p><span>定义</span></p><ul><li><span>== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同。</span></li></ul></li><li><p><span>如何比较</span></p><ul><li><p><span>1、比较的是操作符两端的操作数是否是同一个对象</span></p></li><li><p><span>2、两边的操作数必须是同一类型的（可以是父子类之间），才能通过编译</span></p></li><li><p><span>3、比较的是地址</span></p><ul><li><span>如果是具体的阿拉伯数字的比较，值相等则为true，int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），都指向地址为10的堆。</span></li></ul></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较</span></li><li><span>两个Integer类型进行“==”比较， 判断其值是否在-128至127之间(进行缓存)，否则生成新的Integer对象</span></li></ul></li></ul></li><li><p><span>equals</span></p><ul><li><p><span>定义</span></p><ul><li><span>equals用来比较的是两个对象的内容是否相等</span></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>1、需要实现对equals的重写或覆盖，原本是Object中的equals()，等效于==</span></li><li><span>2、两个基本型的封装型进行equals()比较，首先比较类型，再比较值</span></li><li><span>3、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行比较</span></li><li><span>4、与常量比较时，把常量放前面，防止空指针</span></li></ul></li></ul></li></ul><h3 id='hashcode的作用'><span>Hashcode的作用</span></h3><ul><li><span>hashCode根据对象的内存地址换算出的一个值，用来在散列存储结构中确定对象的存储地址的</span></li></ul><h3 id='stringstring-stringbuffer-和-stringbuilder-的区别是什么'><span>String、String StringBuffer 和 StringBuilder 的区别是什么？</span></h3><ul><li><span>String是只读字符串，它并不是基本数据类型，而是一个对象。底层是final类型的字符数组，每次操作String都会new String。</span></li><li><span>StringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类，底层都是可变的字符数组</span></li><li><span>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，线程安全。</span></li></ul><h3 id='arraylist和linkedlist的区别'><span>ArrayList和linkedList的区别</span></h3><ul><li><p><span>Array（数组）</span></p><ul><li><span>基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。</span></li><li><span>添加/删除效率低，要移动前后的元素</span></li></ul></li><li><p><span>List(集合)</span></p><ul><li><span>是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。</span></li></ul></li><li><p><span>ArrayList</span></p><ul><li><span>底层的实现是Array, 数组扩容实现基于动态数组的数据结构</span></li></ul></li><li><p><span>LinkedList</span></p><ul><li><span>在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList。</span></li></ul></li></ul><h3 id='hashmap和hashtable的区别'><span>HashMap和HashTable的区别</span></h3><ul><li><span>1、两者父类不同</span></li><li><span>2、对外提供的接口不同</span></li><li><span>3、对null的支持不同</span></li><li><span>4、安全性不同</span></li><li><span>5、初始容量大小和每次扩充容量大小不同</span></li><li><span>6、计算hash值的方法不同</span></li></ul><h3 id='collection包结构与collections的区别'><span>Collection包结构，与Collections的区别</span></h3><ul><li><span>Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set</span></li><li><span>Collections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。</span></li></ul><h3 id='java的四种引用强弱软虚'><span>Java的四种引用，强弱软虚</span></h3><ul><li><p><span>强引用</span></p><ul><li><span>强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收</span></li></ul></li><li><p><span>软引用</span></p><ul><li><span>软引用在程序内存不足时，会被回收，</span></li><li><span>创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。</span></li></ul></li><li><p><span>弱引用</span></p><ul><li><span>弱引用就是只要JVM垃圾回收器发现了它，就会将之回收</span></li><li><span>Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用</span></li><li><span>一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作</span></li></ul></li><li><p><span>虚引用</span></p><ul><li><span>跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中</span></li><li><span>其它引用是被JVM回收后才被传入 ReferenceQueue 中的</span></li><li><span>被用于引用销毁前的处理工作</span></li></ul></li></ul><h3 id='泛型'><span>泛型</span></h3><ul><li><p><span>定义</span></p><ul><li><p><span>编写的代码可以被不同类型的对象所重用。</span></p></li><li><p><span>具体执行的时候却可以有具体的规则来约束</span></p><ul><li><span>ArraysList</span><Integer><span>()</span></li></ul></li></ul></li><li><p><span>好处</span></p><ul><li><span>我们不必因为添加元素类型的不同而定义不同类型的集合</span></li><li><span>只要把底层存储设置了Object</span></li></ul></li></ul><h3 id='java创建对象有几种方式'><span>Java创建对象有几种方式？</span></h3><ul><li><p><span>创建对象的方式</span></p><ul><li><span>1、new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</span></li><li><span>2、Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</span></li><li><span>3、Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</span></li><li><span>4、使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</span></li><li><span>5、使用序列化：序列化一般用于Socket的网络传输</span></li><li><span>6、第三方库 Objenesis</span></li></ul></li></ul><h3 id='解决哈希冲突的方法'><span>解决哈希冲突的方法？</span></h3><ul><li><p><span>拉链法</span></p><ul><li><span>每个哈希表节点都有一个next指针，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</span></li></ul></li><li><p><span>开放定址法</span></p><ul><li><span>一旦发生了冲突,就去寻找下一个空的散列地址</span></li></ul></li><li><p><span>再哈希</span></p><ul><li><span>有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突</span></li></ul></li></ul><h3 id='深拷贝和浅拷贝'><span>深拷贝和浅拷贝</span></h3><ul><li><p><span>浅拷贝</span></p><ul><li><span>被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象。</span></li></ul></li><li><p><span>深拷贝</span></p><ul><li><span>被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象</span></li><li><span>深拷贝把要复制的对象所引用的对象都复制了一遍。</span></li></ul></li></ul><h3 id='final有哪些用法'><span>final有哪些用法?</span></h3><ul><li><span>被final修饰的类不可以被继承</span></li><li><span>被final修饰的方法不可以被重写</span></li><li><span>被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变</span></li><li><span>被final修饰的方法,JVM会尝试将其内联,以提高运行效率</span></li><li><span>被final修饰的常量,在编译阶段会存入常量池中</span></li></ul><h3 id='static都有哪些用法'><span>static都有哪些用法?</span></h3><ul><li><p><span>静态变量</span></p></li><li><p><span>静态方法</span></p></li><li><p><span>静态代码块</span></p><ul><li><span>初始化操作</span></li></ul></li><li><p><span>静态内部类</span></p></li><li><p><span>静态导包</span></p><ul><li><span>可以不需要使用类名,直接使用资源名(sin(2))</span></li></ul></li></ul><h3 id='aab与ab有什么区别吗'><span>a=a+b与a+=b有什么区别吗?</span></h3><ul><li><p><span>+= 操作符会进行隐式自动类型转换</span></p></li><li><p><span>将加操作的结果类型(左边)转换为持有结果的类型(右边)</span></p></li><li><p><span>例子</span></p><ul><li><span>short s1= 1; // 报转换类型异常</span>
<span>s1 = s1 + 1;</span></li><li><span>byte、short运算时自动提升为int类型</span></li></ul></li></ul><h3 id='finally的执行机制'><span>finally的执行机制</span></h3><ul><li><p><span>原理</span></p><ul><li><span>如果try和catch中有return，首先会把返回值保存起来，然后去执行finally的代码，最后进行返回</span></li><li><span>函数返回值在finally执行前确定</span></li></ul></li></ul><h3 id='什么情况下finally不执行'><span>什么情况下finally不执行？</span></h3><ul><li><span>try{} catch{} 语句之前有return或者异常退出程序</span></li><li><span>try{} catch{} 语句之前有存在死循环</span></li><li><span>调用System.exit()，程序立即退出(JVM停止)</span></li></ul><h3 id='excption与error包结构'><span>Excption与Error包结构</span></h3><h3 id='oom你遇到过哪些情况sof你遇到过哪些情况'><span>OOM你遇到过哪些情况，SOF你遇到过哪些情况？</span></h3><ul><li><p><span>OOM(OutOfMemoryError)</span></p><ul><li><p><span>堆</span></p><ul><li><span>内存泄露或者堆的大小设置不当</span></li></ul></li><li><p><span>方法区</span></p><ul><li><span>大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP等频繁自定义类加载器的场景</span></li></ul></li><li><p><span>栈</span></p><ul><li><p><span>1、递归调用</span></p></li><li><p><span>2、大量循环或死循环</span></p></li><li><p><span>3、全局变量是否过多</span></p><ul><li><span>局部变量表过大</span></li></ul></li><li><p><span>4、数组、List、map数据是否过大</span></p></li></ul></li></ul></li><li><p><span>SOF(StackOverflow)</span></p><ul><li><p><span>栈</span></p><ul><li><p><span>1、递归调用</span></p></li><li><p><span>2、大量循环或死循环</span></p></li><li><p><span>3、全局变量是否过多</span></p><ul><li><span>局部变量表过大</span></li></ul></li><li><p><span>4、数组、List、map数据是否过大</span></p></li></ul></li></ul></li></ul><h3 id='简述线程程序进程的基本概念以及他们之间关系是什么'><span>简述线程、程序、进程的基本概念。以及他们之间关系是什么?</span></h3><ul><li><p><span>线程(Thread)</span></p><ul><li><p><span>定义</span></p><ul><li><span>操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</span></li><li><span>系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位</span></li></ul></li><li><p><span>分类</span></p><ul><li><p><span>用户线程</span></p><ul><li><span>平时用到的普通线程,自定义线程</span></li></ul></li><li><p><span>守护线程</span></p><ul><li><span>运行在后台,是一种特殊的线程,比如垃圾回收</span></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>当主线程结束后,用户线程还在运行,JVM 存活；如果没有用户线程,都是守护线程,JVM 结束</span></li></ul></li></ul></li></ul></li><li><p><span>进程(Process)</span></p><ul><li><span>计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</span></li><li><span>在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位</span></li></ul></li><li><p><span>程序</span></p><ul><li><span>含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中</span></li><li><span>静态的代码。</span></li></ul></li></ul><h3 id='有些字段不想进行序列化'><span>有些字段不想进行序列化？</span></h3><ul><li><p><span>transient</span></p><ul><li><span>阻止实例中那些用此关键字修饰的的变量序列化</span></li><li><span>对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复</span></li><li><span>只能修饰变量，不能修饰类和方法</span></li></ul></li></ul><h3 id='说说java-中-io-流'><span>说说Java 中 IO 流</span></h3><h3 id='java反射的作用与原理'><span>Java反射的作用与原理</span></h3><ul><li><p><span>作用</span></p><ul><li><span>只要给定类的名字，就可以通过反射机制来获得类的所有信息</span></li></ul></li><li><p><span>原理</span></p><ul><li><span>在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。</span></li><li><span>这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</span></li></ul></li><li><p><span>场景</span></p><ul><li><span>jdbc加载Mysql的驱动类</span></li></ul></li></ul><h3 id='listsetmap三者的区别'><span>List,Set,Map三者的区别？</span></h3><ul><li><p><span>List(对付顺序的好帮手)</span></p><ul><li><span>List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</span></li></ul></li><li><p><span>Set(注重独一无二的性质)</span></p><ul><li><span>不允许重复的集合。不会有多个元素引用相同的对象。</span></li></ul></li><li><p><span>Map(用Key来搜索的专家)</span></p><ul><li><span>使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</span></li></ul></li></ul><h3 id='object的方法'><span>Object的方法？</span></h3><ul><li><p><span>clone </span></p><ul><li><span>实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法</span></li><li><span>深拷贝也需要实现 Cloneable，同时其成员变量为引用类型的也需要实现 Cloneable，然后重写 clone 方法。</span></li></ul></li><li><p><span>finalize </span></p><ul><li><span>对象回收前调用，只调用一次，判断对象是否复活</span></li></ul></li><li><p><span>equals</span></p><ul><li><span>相当于==，子类需要重写</span></li></ul></li><li><p><span>hashCode</span></p><ul><li><span>用于哈希查找</span></li><li><span>重写了 equals 方法一般都要重写 hashCode 方法，在一些具有哈希功能的 Collection 中用到。</span></li></ul></li><li><p><span>wait(time)</span></p><ul><li><span>使当前线程等待该对象的锁</span></li><li><span>配合 synchronized 使用，当前线程必须是该对象的拥有者，也就是具有该对象的锁。</span></li></ul></li><li><p><span>notify</span></p><ul><li><span>唤醒在该对象上等待队列中的某个线程</span></li><li><span>配合 synchronized 使用</span></li><li><span>同步队列中的线程是给抢占 CPU 的线程，等待队列中的线程指的是等待唤醒的线程。</span></li></ul></li><li><p><span>notifyAll </span></p><ul><li><span>配合 synchronized 使用，该方法唤醒在该对象上等待队列中的所有线程</span></li></ul></li></ul><h3 id='获取一个类class对象的方式有哪些'><span>获取一个类Class对象的方式有哪些？</span></h3><ul><li><p><span>获取Class对象的方式？</span></p><ul><li><p><span>1.通过实例对象获得</span></p><ul><li><span>Class class1 = person.getClass();</span></li></ul></li><li><p><span>2.通过全类名获得(包名+类名)</span></p><ul><li><span>Class class2 = Class.forName(&quot;reflection.Student&quot;);</span></li></ul></li><li><p><span>3.通过类的静态成员class获得</span></p><ul><li><span>Class class3 = Person.class;</span></li></ul></li><li><p><span>4.只针对内置的基本数据类型</span></p><ul><li><span>Class class4 = Integer.TYPE;</span></li></ul></li></ul></li></ul><h3 id='为什么arrayslist不安全'><span>为什么ArraysList不安全？</span></h3><ul><li><span>add()不是原子性操作</span></li><li><span>执行add()时，先将数组的长度+1，在多线程情况下，可能效果只有一个</span></li></ul><h3 id='说说什么是-fail-fast'><span>说说什么是 fail-fast？</span></h3><ul><li><span>Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。</span></li><li><span>当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变就会抛出异常，产生fail-fast事件。</span></li><li><span>add、remove 和 clear</span></li></ul><h3 id='hashmap-中的-key-我们可以使用任何类作为-key-吗'><span>HashMap 中的 key 我们可以使用任何类作为 key 吗？</span></h3><ul><li><p><span>可以</span></p><ul><li><span>1、如果类重写了 equals 方法，它也应该重写 hashCode 方法</span></li><li><span>2、类的所有实例需要遵循与 equals 和 hashCode 相关的规则</span></li><li><span>3、如果一个类没有使用 equals，你不应该在 hashCode 中使用它</span></li><li><span>4、咱们自定义 key 类的最佳实践是使之为不可变的这样，hashCode 值可以被缓存起来，拥有更好的性能</span></li></ul></li></ul><h3 id='hashmap-与-concurrenthashmap-的异同'><span>HashMap 与 ConcurrentHashMap 的异同</span></h3><ul><li><span>1、都是 key-value 形式的存储数据</span></li><li><span>2、HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的；</span></li><li><span>3、HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑树。</span></li><li><span>4、 ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry；JDK 1.8 之后，采用 Node + CAS + Synchronized来保证并发安全进行实现。</span></li></ul><h3 id='说说你平时是怎么处理-java-异常的'><span>说说你平时是怎么处理 Java 异常的？</span></h3><h3 id='什么是jdk什么是jre'><span>什么是JDK？什么是JRE?</span></h3><ul><li><p><span>JDK(java development kit)</span></p><ul><li><span>java开发工具包，使用java语言编写java程序所需的开发工具包</span></li><li><span>编写java程序</span></li><li><span>jdk包含jre</span></li></ul></li><li><p><span>JRE(java runtime environment)</span></p><ul><li><span>java运行环境，包含了java虚拟机，java基础类库，是使用java语言编写的程序运行所需要的软件环境</span></li><li><span>运行java程序</span></li></ul></li></ul><h3 id='为什么重写equals一定要重写hashcode'><span>为什么重写equals一定要重写hashcode？</span></h3><ul><li><span>默认的hashcode方法是根据对象的内存地址经哈希算法得到的，如果不重写的话，那么在两个相同的对象在使用equals方法的时候就有可能不同</span></li></ul><h3 id='接口和抽象类的区别'><span>接口和抽象类的区别？</span></h3><ul><li><span>1、接口中的所有方法都是抽象的，而抽象类可以有抽象的和非抽象的</span></li><li><span>2、类可以实现很多个接口，但只能继承一个抽象类</span></li><li><span>3、类可以不实现抽象类和接口声明的所有方法，但是该类必须声明成抽象的</span></li><li><span>4、接口的成员方法默认是public，而抽象类的成员可以是private，protected，public</span></li><li><span>5、JDK1.8开始，接口中可以包含default方法（可以进行实现），但是抽象类没有</span></li></ul><h3 id='error-和-exception-的区别'><span>Error 和 Exception 的区别?</span></h3><ul><li><p><span>1、Exception是程序正常运行中,可以预料的意外情况,可以被捕获,进行相应的处理</span></p></li><li><p><span>2、Error 是指正常情况下,不大可能出现的情况,绝大部分的Error 都会导致程序处于非正常的,不可恢复的状态, 不需要捕获</span></p></li><li><p><span>3、Exception 分为可检查异常(checked) 和 不可检查异常(unchecked)</span></p><ul><li><span>可检查异常在源代码里必须显式的进行捕获处理,这是编译期检查的一部分</span></li><li><span>不可检查异常是指运行时异常(空指针，数组越界)， 通常是可以编码避免的逻辑错误,具体根据需要来判断是否需要捕获。</span></li></ul></li></ul><h3 id='常见的检查异常和非检查异常'><span>常见的检查异常和非检查异常？</span></h3><ul><li><p><span>检查</span></p><ul><li><span>ClassNotFoundException // 找不到具有指定名称的类的定义</span></li><li><span>DataFormatException //数据格式异常</span></li><li><span>IOException //输入输出异常</span></li><li><span>SQLException //提供有关数据库访问错误或其他错误的信息的异常</span></li><li><span>FileNotFoundException //当试图打开指定路径名表示的文件失败时，抛出此异常</span></li><li><span>EOFException //当输入过程中意外到达文件或流的末尾时，抛出此异常</span></li></ul></li><li><p><span>非检查</span></p><ul><li><span>ArrayIndexOutOfBoundsException //用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引</span></li><li><span>ArithmeticException //当出现异常的运算条件时，抛出此异常。（ 例如，一个整数“除以零”时，抛出此类的一个实例）</span></li><li><span>IllegaArguementException //抛出的异常表明向方法传递了一个不合法或不正确的参数</span></li><li><span>NullPointerException //空指针异常（调用 null 对象的实例方法等）</span></li><li><span>ClassCastException //类转换异常</span></li><li><span>ArrayStoreException //数据存储异常，操作数组时类型不一致</span></li></ul></li></ul><h3 id='oop'><span>OOP</span></h3><ul><li><p><span>核心思想(特性)</span></p><ul><li><p><span>封装</span></p><ul><li><span>每个类（对象的模板）可以自由地定义属性和方法，使其有别于其他的类。</span></li><li><span>封装可以隐藏对象的内部细节，使其对外形成一道边界，只保留有限的属性和方法与其他对象进行交互。</span></li><li><span>封装的原则是使对象以外的部分不能随意的访问和操作对象的内部属性，从而避免了外界对对象内部属性的破坏。</span></li></ul></li><li><p><span>继承</span></p><ul><li><span>子类使用extends可以轻松地复用父类的代码（非 private 修饰的属性和方法）</span></li><li><span>如果父类的属性不满足子类的需求，可以追加；如果父类的方法不满足子类的需求，可以覆盖</span></li></ul></li><li><p><span>多态</span></p><ul><li><span>父类中定义的方法被子类继承之后，可以表现出不同的行为。这使得同一个方法在父类及其各个子类中具有不同的语义</span></li><li><span>重写，重载</span></li></ul></li></ul></li><li><p><span>子主题 2</span></p></li></ul><h3 id='修饰符'><span>修饰符</span></h3><ul><li><p><span>类</span></p><ul><li><p><span>访问控制符</span></p><ul><li><p><span>public</span></p><ul><li><span>一个Java程序一个public</span></li></ul></li></ul></li><li><p><span>非访问控制符</span></p><ul><li><p><span>abstract</span></p><ul><li><span>抽象类</span></li></ul></li><li><p><span>final</span></p><ul><li><span>不能被继承的类</span></li></ul></li><li><p><span>default</span></p><ul><li><span>只能被同一个包的类访问或引用</span></li></ul></li></ul></li></ul></li><li><p><span>方法</span></p><ul><li><p><span>访问控制符</span></p><ul><li><span>public、private、protected、default</span></li></ul></li><li><p><span>非访问控制符</span></p><ul><li><span>abstract、static、final、native、synchronized</span></li></ul></li></ul></li><li><p><span>变量</span></p><ul><li><p><span>访问控制符</span></p><ul><li><p><span>public</span></p><ul><li><span>公共</span></li></ul></li><li><p><span>private</span></p><ul><li><p><span>私有</span></p><ul><li><span>只能被该类自身访问</span></li></ul></li></ul></li><li><p><span>protected</span></p><ul><li><p><span>保护</span></p><ul><li><span>类自身、同一个包中的其它类、其它包的子类</span></li></ul></li></ul></li><li><p><span>default</span></p><ul><li><p><span>缺省默认修饰符</span></p><ul><li><span>类自身、同一个包中的其它类</span></li></ul></li></ul></li></ul></li><li><p><span>非访问控制符</span></p><ul><li><p><span>static</span></p><ul><li><span>仅属于类的变量</span></li></ul></li><li><p><span>final</span></p><ul><li><span>常量，程序执行中不再变</span></li></ul></li><li><p><span>volatile</span></p><ul><li><span>多线程下保证变量的可见性</span></li></ul></li><li><p><span>transient</span></p><ul><li><span>暂时性变量</span></li></ul></li></ul></li></ul></li></ul><h2 id='javase'><span>JavaSE</span></h2><h3 id='多线程'><span>多线程</span></h3><ul><li><p><span>基本概念</span></p><ul><li><p><span>程序(program)</span></p><ul><li><span>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象</span></li></ul></li><li><p><span>进程(process)</span></p><ul><li><span>是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程</span></li></ul></li><li><p><span>线程(thread)</span></p><ul><li><span>进程可进一步细化为线程，是一个程序内部的一条执行路径</span></li></ul></li></ul></li><li><p><span>线程创建的方式</span></p><ul><li><p><span>分类</span></p><ul><li><p><span>继承Thread类</span></p><ul><li><ol start='' ><li><span>定义子类继承Thread类。</span></li></ol></li></ul></li></ul></li></ul></li></ul><ol start='2' ><li><p><span>子类中重写Thread类中的run方法。</span></p></li><li><p><span>创建Thread子类对象，即创建了线程对象。</span></p></li><li><p><span>调用线程对象start方法：启动线程，调用run方法。</span></p><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 10.8px; left: 33px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 29px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -29px; width: 29px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -29px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 21px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">- 实现Runnable接口</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -29px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 21px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -29px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 21px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span>- 1) 定义子类，实现Runnable接口。</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 78px;"></div><div class="CodeMirror-gutters" style="height: 78px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 29px;"></div></div></div></div></pre></li><li><p><span>子类中重写Runnable接口中的run方法。</span></p></li><li><p><span>通过Thread类含参构造器创建线程对象。</span></p></li><li><p><span>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</span></p></li><li><p><span>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</span></p><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 10.8px; left: 33px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 29px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>3</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -29px; width: 29px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -29px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 21px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">- 实现Callable接口</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -29px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 21px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -29px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 21px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span>- ThreadCreate3 threadCreate3 = new ThreadCreate3();</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 78px;"></div><div class="CodeMirror-gutters" style="height: 78px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 29px;"></div></div></div></div></pre><p><span>// 1.创建执行服务</span>
<span>ExecutorService service = Executors.newFixedThreadPool(1); // 线程池</span>
<span>// 2.提交执行</span>
<span>Future</span><Boolean><span> submit = service.submit(threadCreate3);</span>
<span>// 3.获取结果</span>
<span>Boolean rs = submit.get();</span>
<span>// 4.关闭服务</span>
<span>service.shutdown();</span></p><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 10.8px; left: 33px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 29px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>1</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -29px; width: 29px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -29px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 21px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">- 线程池创建</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="height: 26px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 29px;"></div></div></div></div></pre><ul><li><p><span>继承和实现的区别</span></p><ul><li><span>1、继承的线程代码存在于子类的run；实现的线程代码存在于接口的子类的run</span></li><li><span>2、实现方式避免了单继承</span></li><li><span>3、多个线程可以共享同一个接口实现类的对象，适合多个相同线程来处理同一份资源</span></li></ul></li></ul></li></ol><ul><li><p><span>线程的状态</span></p><ul><li><p><span>分类</span></p><ul><li><p><span>NEW(新建)</span></p><ul><li><span>新创建了一个线程对象，但还没有调用start()方法。</span></li></ul></li><li><p><span>RUNNABLE(运行）</span></p><ul><li><p><span>Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”</span></p></li><li><p><span>调用start()方法或者资源完整等待CPU使用权</span></p><ul><li><span>start()方法进入的是运行的就绪态</span></li></ul></li><li><p><span>子主题 3</span></p></li></ul></li><li><p><span>BLOCKED（阻塞）</span></p><ul><li><span>等待锁</span></li></ul></li><li><p><span>WAITING（等待）</span></p><ul><li><span>等待被唤醒</span></li></ul></li><li><p><span>TIMED_WAITING（超时等待）</span></p><ul><li><span>等待一定时间自动唤醒</span></li></ul></li><li><p><span>TERMINATED(终止)</span></p><ul><li><span>线程执行完毕</span></li></ul></li></ul></li><li><p><span>方法</span></p><ul><li><p><span>setPriority(int newPriority) </span></p><ul><li><span>更改线程的优先级</span></li></ul></li><li><p><span>static void sleep(long millis) </span></p><ul><li><p><span>在指定的毫秒数内让当前正在执行的线程休眠</span></p><ul><li><span>必须有值</span></li></ul></li></ul></li><li><p><span>void join() </span></p><ul><li><span>等待该线程终止</span></li></ul></li><li><p><span>static void yield() </span></p><ul><li><span>暂停当前正在执行的线程对象（变为就绪态），并执行其他线程</span></li></ul></li><li><p><span>void interrupt() </span></p><ul><li><span>中断线程，别用这个方式</span></li></ul></li><li><p><span>boolean isAlive() </span></p><ul><li><span>测试线程是否处于活动状态</span></li></ul></li><li><p><span>void start()</span></p><ul><li><span>使线程进入运行的就绪态</span></li></ul></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>1、start()不会马上执行线程，而是进入运行的就绪态(ready)</span></li><li><span>2、系统调度才是使线程变为运行中(running)的唯一途径</span></li><li><span>3、某个线程拿到锁、sleep()方法结束也会进入就绪态</span></li></ul></li><li><p><span>Thread.join()</span></p><ul><li><p><span>定义</span></p><ul><li><span>主线程等待子线程的终止</span></li><li><span>主线程调用了子线程的join()方法，主线程阻塞至子线程执行完成</span></li></ul></li><li><p><span>场景</span></p><ul><li><span>主线程先于子线程完成，但主线程又需要子线程的处理结果</span></li></ul></li></ul></li><li><p><span>状态图</span></p><ul><li></li></ul></li></ul></li><li><p><span>等待队列和同步队列</span></p><ul><li><p><span>等待队列</span></p><ul><li><span>存放的是等待/超时等待的线程</span></li><li><span>每个对象一个</span></li></ul></li><li><p><span>同步队列</span></p><ul><li><span>存放的是竞争对象锁的线程</span></li><li><span>每个对象一个</span></li></ul></li></ul></li><li><p><span>线程同步</span></p><ul><li><p><span>同步锁</span></p><ul><li><p><span>定义</span></p><ul><li><span>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）</span></li><li><span>一种防止两个任务访问相同的资源（其实就是共享资源竞争）的方式</span></li></ul></li><li><p><span>同步监视器</span></p><ul><li><span>同步代码块指定要锁的对象</span></li></ul></li></ul></li><li><p><span>synchronized</span></p><ul><li><p><span>锁</span></p><ul><li><p><span>同步方法的锁</span></p><ul><li><span>静态方法（类名.class，Class类模板，一个类只有一个Class对象）</span></li><li><span>非静态方法（this，当前实例对象）</span></li></ul></li><li><p><span>同步代码块的锁</span></p><ul><li><span>自己指定，很多时候也是指定为this或类名.class</span></li></ul></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>所有操作共享数据的这些语句都要放在同步范围中</span></li><li><span>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this）</span></li></ul></li></ul></li><li><p><span>lock</span></p><ul><li><span>与syschronized类似</span></li></ul></li><li><p><span>synchronized 与 Lock 的对比</span></p><ul><li><span>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放</span></li><li><span>Lock只有代码块锁，synchronized有代码块锁和方法锁</span></li><li><span>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</span></li></ul></li></ul></li><li><p><span>线程通信</span></p><ul><li><p><span>通信方式</span></p><ul><li><p><span>共享内存</span></p><ul><li><span>线程之间通过写-读内存中的公共状态来隐式进行通信。</span></li><li><span>典型的共享内存通信方式，就是通过共享对象进行通信</span></li></ul></li><li><p><span>消息传递</span></p><ul><li><span>线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信</span></li><li><span>在 Java 中典型的消息传递方式，就是 wait() 和 notify() ，或者 BlockingQueue</span></li></ul></li></ul></li><li><p><span>子主题 2</span></p></li><li><p><span>子主题 3</span></p></li></ul></li><li><p><span>死锁的产生和解决</span></p><ul><li><p><span>定义</span></p><ul><li><span>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</span></li><li><span>不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态</span></li></ul></li><li><p><span>四个必要条件</span></p><ul><li><span>互斥条件：一个资源每次只能被一个进程使用</span></li><li><span>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</span></li><li><span>不剥夺条件 : 进程已获得的资源，在末使用完之前，不能强行剥夺</span></li><li><span>循环等待条件 : 若干进程之间形成一种头尾相接的循环等待资源关系</span></li></ul></li><li><p><span>解决方案</span></p><ul><li><p><span>银行家算法</span></p><ul><li><p><span>定义</span></p><ul><li><span>子主题 1</span></li></ul></li></ul></li></ul></li></ul></li><li><p><span>如何停止正在运行的线程？</span></p><ul><li><span>正常退出</span></li><li><span>使用stop方法强行终止</span></li><li><span>使用interrupt方法中断线程</span></li></ul></li><li><p><span>notify()和notifyAll()有什么区别？</span></p></li></ul><h3 id='反射'><span>反射</span></h3><ul><li><p><span>定义</span></p><ul><li><p><span>允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</span></p></li><li><p><span>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。</span></p></li><li><p><span>过程</span></p><ul><li><p><span>正常方式</span></p><ul><li><span>引入需要的”包类”名称 ----&gt;通过new实例化 ----&gt;取得实例化对象</span></li></ul></li><li><p><span>反射方式</span></p><ul><li><span>实例化对象----&gt;getClass()方法 ----&gt;得到完整的“包类”名</span></li></ul></li></ul></li></ul></li><li><p><span>静态语言与动态语言</span></p><ul><li><p><span>静态语言</span></p><ul><li><span>运行时结构不可变的语言就是静态语言</span></li></ul></li><li><p><span>动态语言</span></p><ul><li><span>在运行时代码可以根据某些条件改变自身结构</span></li></ul></li></ul></li><li><p><span>获取Class对象的方式？</span></p><ul><li><p><span>1.通过实例对象获得</span></p><ul><li><span>Class class1 = person.getClass();</span></li></ul></li><li><p><span>2.通过全类名获得(包名+类名)</span></p><ul><li><span>Class class2 = Class.forName(&quot;reflection.Student&quot;);</span></li></ul></li><li><p><span>3.通过类的静态成员class获得</span></p><ul><li><span>Class class3 = Person.class;</span></li></ul></li><li><p><span>4.只针对内置的基本数据类型</span></p><ul><li><span>Class class4 = Integer.TYPE;</span></li></ul></li></ul></li><li><p><span>具有Class的数据类型？</span></p><ul><li><p><span>数据类型</span></p><ul><li><span>Class c1 = Object.class;</span>
<span>Class c2 = Comparable.class; // 接口</span>
<span>Class c3 = String[].class;</span>
<span>Class c4 = int</span>[][]<span>.class;</span>
<span>Class c5 = ElementType.class; // 枚举</span>
<span>Class c6 = Override.class;  // 接注解</span>
<span>Class c7 = Integer.class;</span>
<span>Class c8 = void.class;</span>
<span>Class c9 = Class.class;</span></li></ul></li><li><p><span>//只要元素类型与维度一样,就是同一个Class</span>
<span>int[] a = new int[10];</span>
<span>int[] b = new int[100];</span></p></li></ul></li><li><p><span>类发生初始化的时机？</span></p><ul><li><p><span>类的主动引用</span></p><ul><li><span>1、当虚拟机启动，先初始化main方法所在的类</span></li><li><span>2、new一个类的对象</span></li><li><span>3、调用类的静态成员（除了final常量）和静态方法</span></li><li><span>4、使用java.lang.reflect包的方法对类进行反射调用</span></li><li><span>5、当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</span></li></ul></li><li><p><span>类的被动引用</span></p><ul><li><p><span>1、当访问一个静态域时，只有真正声明这个域的类才会被初始化</span></p><ul><li><span>当通过子类引用父类的静态变量，不会导致子类初始化，只是存放了指向这个变量的引用</span></li></ul></li><li><p><span>2、通过数组定义类引用，不会触发此类的初始化</span></p><ul><li><span>只是定义了一个变量名和开辟了一块空间</span></li></ul></li><li><p><span>3、引用常量不会触发此类的初始化</span></p><ul><li><span>常量在链接阶段就存入调用类的常量池中了</span></li></ul></li></ul></li></ul></li><li><p><span>如何通过反射获取注解？</span></p><ul><li><p><span>获取所有注解</span></p><ul><li><span>Class&lt;?&gt; c = Class.forName(&quot;reflection.Student1&quot;);</span>
<span>Annotation[] annotations = c.getAnnotations();</span></li></ul></li><li><p><span>获取类中指定注解</span></p><ul><li><span>Field id = c.getDeclaredField(&quot;id&quot;);</span>
<span>FiledAnnotation annotation1 = id.getAnnotation(FiledAnnotation.class);</span></li><li><span>先通过反射获取属性，再获取注解</span></li></ul></li><li><p><span>获取注解的value值</span></p><ul><li><span>annotation.value();</span></li></ul></li></ul></li><li><p><span>如何通过反射动态创建对象？</span></p><ul><li><p><span>// 获取Class对象</span>
<span>Class&lt;?&gt; c = Class.forName(&quot;pojo.User&quot;);</span>
<span>Object o = c.newInstance();  //本质调用了类的无参构造器，权限必须是public</span></p></li><li><p><span>通过构造器创建对象</span></p><ul><li><span>Constructor&lt;?&gt; constructor = c.getConstructor(int.class, String.class);</span>
<span>Object admin = constructor.newInstance(1, &quot;admin&quot;);  //本质调用了类的构造器，权限没有要求</span></li></ul></li><li><p><span>通过反射调用方法</span></p><ul><li><p><span>User user = (User) c.newInstance();</span>
<span>Method setId = c.getDeclaredMethod(&quot;setId&quot;, int.class);</span>
<span>setId.invoke(user,10086); // invoke(对象，&quot;方法的值&quot;)</span></p><ul><li><span>invoke调用方法</span></li></ul></li></ul></li><li><p><span>通过反射调用属性</span></p><ul><li><span>user = (User) c.newInstance();</span>
<span>Field id = c.getDeclaredField(&quot;id&quot;);</span>
<span>id.setAccessible(true); // 私有属性无法访问，setAccessible是启动和禁用访问安全检查的开关，关闭安全检测</span>
<span>id.set(user,10);</span></li></ul></li></ul></li><li><p><span>如何获取运行时类的完整结构？</span></p><ul><li><p><span>1.实现的全部接口</span></p><ul><li><span>public Class&lt;?&gt;[] getInterfaces()</span></li></ul></li><li><p><span>2.所继承的父类</span></p><ul><li><span>public Class&lt;? Super T&gt; getSuperclass()</span></li></ul></li><li><p><span>3.全部的构造器</span></p><ul><li><p><span>public Constructor</span><T><span>[] getConstructors() ；// public</span></p></li><li><p><span>public Constructor</span><T><span>[] getDeclaredConstructors()</span></p></li><li><p><span>Constructor</span></p><ul><li><span>public int getModifiers();  取得修饰符</span>
<span>public String getName(); 取得方法名称:</span>
<span>public Class&lt;?&gt;[] getParameterTypes(); 取得参数的类型</span></li></ul></li></ul></li><li><p><span>4.全部的方法</span></p><ul><li><p><span>public Method[] getMethods()；// public</span></p></li><li><p><span>public Method[] getDeclaredMethods()</span></p></li><li><p><span>Methord</span></p><ul><li><span>public Class&lt;?&gt; getReturnType()取得全部的返回值</span></li><li><span>public Class&lt;?&gt;[] getParameterTypes()取得全部的参数</span></li><li><span>public int getModifiers()取得修饰符</span></li><li><span>public Class&lt;?&gt;[] getExceptionTypes()取得异常信息</span></li></ul></li></ul></li><li><p><span>5.全部的Field</span></p><ul><li><p><span>public Field[] getFields()； // public</span></p></li><li><p><span>public Field[] getDeclaredFields() </span></p></li><li><p><span>Filed</span></p><ul><li><span>public int getModifiers() 以整数形式返回此Field的修饰符</span></li><li><span>public Class&lt;?&gt; getType() 得到Field的属性类型</span></li><li><span>public String getName() 返回Field的名称。</span></li></ul></li></ul></li></ul></li><li><p><span>如何调用运行时类的指定结构？</span></p><ul><li><p><span>1.调用指定方法</span></p><ul><li><span>Object invoke(Object obj, Object … args)</span></li></ul></li><li><p><span>2.调用指定属性</span></p><ul><li><span>c Object get(Object obj)</span></li><li><span>void set(Object obj,Object value)</span></li></ul></li><li><p><span>setAccessible</span></p><ul><li><p><span>Method和Field、Constructor对象都有setAccessible()方法</span></p></li><li><p><span>作用</span></p><ul><li><span>取消Java语言访问检查，提高反射的效率</span></li><li><span>可以访问原有的私有成员</span></li></ul></li></ul></li></ul></li><li><p><span>优缺点</span></p><ul><li><p><span>优点</span></p><ul><li><span>能够运行时动态获取类的实例，提高灵活性</span></li><li><span>与动态编译结合</span></li></ul></li><li><p><span>缺点</span></p><ul><li><p><span>性能较低，需要解析字节码，将内存中的对象进行解析</span></p><ul><li><span>setAccessible(true) 关闭检查</span></li></ul></li><li><p><span>相对不安全，破坏了封装性（可以获取私有属性和方法）</span></p></li></ul></li></ul></li></ul><h3 id='注解'><span>注解</span></h3><ul><li><p><span>元注解</span></p><ul><li><span>@Target : 用于描述注解的使用范围(即:被描述的注解可以用在什么地方)</span></li><li><span>@Retention : 表示需要在什么级别保存该注释信息 , 用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME)</span></li><li><span>@Document：说明该注解将被包含在javadoc中</span></li><li><span>@Inherited：说明子类可以继承父类中的该注解</span></li></ul></li><li><p><span>自定义注解</span></p><ul><li><p><span>@interface</span></p><ul><li><span>@Target(value = {ElementType.METHOD})</span>
<span>@Retention(value = RetentionPolicy.RUNTIME)</span>
<span>@interface MyAnnotation2{</span>
<span>//参数类型 , 参数名</span>
<span>String name() default &quot;&quot;;</span>
<span>int age() default 0;</span>
<span>int id() default -1;  //String indexOf(&quot;abc&quot;) -1 , 不存在,找不到</span>
<span>String[] users() default {&quot;username&quot;,&quot;admin&quot;};</span>
<span>}</span></li></ul></li></ul></li><li><p><span>编译时进行格式检查的注解</span></p><ul><li><span>@Override: 限定重写父类方法, 该注解只能用于方法</span></li><li><span>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</span></li><li><span>@SuppressWarnings: 抑制编译器警告</span></li></ul></li><li><p><span>反射操作注解</span></p></li></ul><h3 id='io流'><span>IO流</span></h3><ul><li><p><span>File类</span></p><ul><li><p><span>常量</span></p><ul><li><p><span>public static final String separator</span></p><ul><li><span>根据操作系统，动态的提供分隔符</span></li></ul></li></ul></li><li><p><span>常用构造器</span></p><ul><li><p><span>public File(String pathname)</span></p><ul><li><span>以pathname为路径创建File对象，可以是绝对路径或者相对路径</span></li></ul></li><li><p><span>public File(String parent,String child)</span></p><ul><li><span>以parent为父路径，child为子路径创建File对象</span></li></ul></li><li><p><span>public File(File parent,String child)</span></p><ul><li><span>根据一个父File对象和子文件路径创建File对象</span></li></ul></li></ul></li><li><p><span>常用方法</span></p></li></ul></li><li><p><span>定义</span></p><ul><li><p><span>输入input</span></p><ul><li><span>读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中</span></li></ul></li><li><p><span>输出output</span></p><ul><li><span>将程序（内存）数据输出到磁盘、光盘等存储设备中</span></li></ul></li></ul></li><li><p><span>分类</span></p><ul><li><p><span>数据单位</span></p><ul><li><span>字节流、字符流</span></li></ul></li><li><p><span>流向</span></p><ul><li><span>输入流、输出流</span></li></ul></li><li><p><span>流的角色</span></p><ul><li><span>节点流、处理流</span></li></ul></li></ul></li><li><p><span>四个基类</span></p><ul><li><p><span>InputStream</span></p></li><li><p><span>OutputStream</span></p></li><li><p><span>Reader</span></p></li><li><p><span>Writer</span></p></li><li><p><span>InpuStream&amp;Reader</span></p><ul><li><span>void read(int b/int c);</span></li><li><span>void read(byte[] b/char[] cbuf);</span></li><li><span>void read(byte[] b/char[] buff, int off, int len);</span></li><li><span>void close(); 需要先刷新，再关闭此流</span></li></ul></li><li><p><span>OuputStream&amp;Writer</span></p><ul><li><span>void write(int b/int c);</span></li><li><span>void write(byte[] b/char[] cbuf);</span></li><li><span>void write(byte[] b/char[] buff, int off, int len);</span></li><li><span>void flush();</span></li><li><span>void close(); 需要先刷新，再关闭此流</span></li></ul></li><li><p><span>注意事项</span></p><ul><li><p><span>输出流都有flush方法，强制写入</span></p></li><li><p><span>InputStream与Reader类似；OutputStream与Writer类似</span></p><ul><li><span>具有的方法相同</span></li></ul></li><li><p><span>Writer可以直接操作字符串，本质也是字符数组</span></p></li></ul></li></ul></li><li><p><span>处理流</span></p><ul><li><p><span>缓冲流</span></p><ul><li><p><span>定义</span></p><ul><li><span>为提高读写速度，使用类时创建一个缓冲数组，默认8192字节(8KB)</span></li></ul></li><li><p><span>分类</span></p><ul><li><p><span>BufferedInputStream&amp;BufferedOutputStream</span></p><ul><li><span>一次性从文件中读取8192个字节/字符到缓冲区，再从缓冲区中读取1024字节/字符到程序（缓冲区在内存中）</span></li><li><span>原来是从硬盘中读取1024个字节/字符到程序中</span></li></ul></li><li><p><span>BufferedReader&amp;BufferedWriter</span></p><ul><li><span>readLine()：读取一行字符</span></li><li><span>newLine()：另写一行</span></li></ul></li></ul></li></ul></li><li><p><span>转换流</span></p><ul><li><p><span>定义</span></p><ul><li><span>将字节流转为字符流</span></li></ul></li><li><p><span>分类</span></p><ul><li><p><span>InputStreamReader</span></p><ul><li><span>inputstream--&gt;reader</span></li></ul></li><li><p><span>OutputStreamWriter</span></p><ul><li><span>outputstream--&gt;writer</span></li></ul></li></ul></li><li><p><span>使用场景</span></p><ul><li><p><span>1.字节流中的数据都是字符时</span></p></li><li><p><span>2.处理文件乱码问题</span></p><ul><li><span>第二个参数可以指定字符集</span></li></ul></li><li><p><span>3.实现编码和解码的功能</span></p></li></ul></li></ul></li><li><p><span>数据流</span></p><ul><li><p><span>定义</span></p><ul><li><span>为了操作Java语言的基本数据类型和String的数据而出现的流</span></li></ul></li><li><p><span>分类</span></p><ul><li><span>DataInputStream</span></li><li><span>DataOutputStream</span></li></ul></li><li><p><span>方法</span></p><ul><li><span>read/writeInt()......八种基本数据类型</span></li><li><span>read/writeUTF()：字符编码</span></li><li><span>read/writeFully()：正常读写</span></li></ul></li></ul></li><li><p><span>对象流</span></p><ul><li><p><span>定义</span></p><ul><li><span>用于存储和读取基本数据类型数据或对象的处理流</span></li><li><span>可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来</span></li></ul></li><li><p><span>实质</span></p><ul><li><span>序列化、反序列化</span></li></ul></li><li><p><span>分类</span></p><ul><li><span>ObjectInputStream</span></li><li><span>OjbectOutputSteam</span></li></ul></li><li><p><span>子主题 3</span></p></li></ul></li></ul></li><li><p><span>Java的序列化</span></p><ul><li><p><span>定义</span></p><ul><li><p><span>序列化</span></p><ul><li><span>java对象转换为字节序列（二进制字节组成的数组）</span></li></ul></li><li><p><span>反序列化</span></p><ul><li><span>字节序列恢复为java对象</span></li></ul></li></ul></li><li><p><span>为什么要序列化？</span></p><ul><li><span>对象不只是存储在内存中，它还需要在传输网络中进行传输，并且保存起来之后下次再加载出来（保存在磁盘或传输网络）</span></li><li><span>跨平台存储和进行网络传输</span></li></ul></li><li><p><span>序列化的原理</span></p><ul><li><span>每个序列化的对象都在用一个序列号进行保存，当序列化一个对象时，检查该对象是否被序列化，如果未进行序列化，采用流中的数据进行序列化，并为该对象关联一个序列号；如果已经序列化，直接通过该序列号获取该对象的引用。</span></li></ul></li><li><p><span>序列化的过程？</span></p><ul><li><span>1.将对象实例相关的类元数据输出</span></li><li><span>2.递归地输出类的超类描述，直到没有超类</span></li><li><span>3.类元数据输出之后，开始从最顶层的超类输出对象实例的实际数据值</span></li><li><span>4.从上至下递归输出实例的数据</span></li></ul></li><li><p><span>如何实现序列化？</span></p><ul><li><p><span>Serializable</span></p><ul><li><span>Serializable接口的作用只是标识这个类是需要进行序列化的</span></li></ul></li><li><p><span>Externalizable</span></p><ul><li><span>在writeExternal()方法中手工指定需要序列化的变量，与是否被transient修饰无关</span></li></ul></li><li><p><span>实现Serializable接口+添加writeObject()和readObject()方法。(显+隐序列化)</span></p></li></ul></li><li><p><span>transient</span></p><ul><li><span>只能修饰变量，不再是对象持久化的一部分，反序列化时也无法获取</span></li><li><span>final修饰的变量都不会被序列化</span></li><li><span>实现Externalizable接口的不一定不被序列化</span></li></ul></li><li><p><span>谈谈你对java.io.Serializable接口的理解</span></p><ul><li><span>1、实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。</span></li><li><span>2、不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节</span></li><li><span>3、由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。</span></li></ul></li></ul></li></ul><h3 id='网络编程'><span>网络编程</span></h3><ul><li><p><span>定义</span></p><ul><li><span>通过操作相应API调度计算机资源硬件，并且利用管道（网线）进行数据交互的过程。</span></li></ul></li><li><p><span>InetAddress</span></p><ul><li><p><span>定义</span></p><ul><li><span>InetAddress是java网络的类。通过该类通过得到ip地址和主机名一些信息</span></li></ul></li><li><p><span>获取InetAddress实例</span></p><ul><li><span>public static InetAddress getLocalHost()</span></li><li><span>public static InetAddress getByName(String host)</span></li></ul></li><li><p><span>常用方法</span></p><ul><li><span>public String getHostAddress()：返回 IP 地址字符串（以文本表现形式）</span></li><li><span>public String getHostName()：获取此 IP 地址的主机名</span></li><li><span>public boolean isReachable(int timeout)：测试是否可以达到该地址</span></li></ul></li></ul></li><li><p><span>Socket</span></p><ul><li><p><span>定义</span></p><ul><li><span>套接字，由唯一标识的IP地址和端口号组合</span></li></ul></li><li><p><span>分类</span></p><ul><li><span>流套接字（stream socket）：使用TCP提供可依赖的字节流服务</span></li><li><span>数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务</span></li></ul></li><li><p><span>常用构造器</span></p><ul><li><span>public Socket(InetAddress address,int port)创建一个流套接字并将其连接到指定 IP 地址的指定端口号</span></li><li><span>public Socket(String host,int port)创建一个流套接字并将其连接到指定主机上的指定端口号</span></li></ul></li><li><p><span>常用方法</span></p><ul><li><span>public InputStream getInputStream()返回此套接字的输入流。可以用于接收网络消息</span></li><li><span>public OutputStream getOutputStream()返回此套接字的输出流。可以用于发送网络消息</span></li><li><span>public InetAddress getInetAddress()此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。</span></li><li><span>public InetAddress getLocalAddress()获取套接字绑定的本地地址。 即本端的IP地址</span></li><li><span>public int getPort()此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。</span></li><li><span>public int getLocalPort()返回此套接字绑定到的本地端口。 如果尚未绑定套接字，则返回 -1。</span></li></ul></li></ul></li><li><p><span>TCP</span></p></li><li><p><span>UDP</span></p></li><li><p><span>URL</span></p><ul><li><p><span>定义</span></p><ul><li><span>统一资源定位符，它表示 Internet 上某一资源的地址。</span></li><li><span>一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源</span></li></ul></li><li><p><span>基本结构</span></p><ul><li><span>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表</span></li><li><span>片段名：锚点</span></li></ul></li></ul></li><li><p><span>URI、URL和URN的区别</span></p><ul><li><p><span>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源</span></p></li><li><p><span>URL，是uniform resource locator，统一资源定位符，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate（定位）这个资源。</span></p></li><li><p><span>URN，uniform resource name，统一资源命名，是通过名字来标识资源</span></p></li><li><p><span>区别</span></p><ul><li><span>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。</span></li></ul></li></ul></li></ul><h3 id='java集合'><span>Java集合</span></h3><ul><li><p><span>Collection</span></p><ul><li><p><span>List</span></p><ul><li><p><span>定义</span></p><ul><li><span>元素有序、且可重复，集合中的每个元素都有其对应的顺序索引</span></li></ul></li><li><p><span>ArrayList</span></p><ul><li><p><span>定义</span></p><ul><li><span>可变长数组</span></li></ul></li><li><p><span>实现</span></p><ul><li><p><span>JDK7</span></p><ul><li><span>像饿汉式，直接创建一个初始容量为10的数组</span></li></ul></li><li><p><span>JDK8</span></p><ul><li><span>像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</span></li></ul></li><li><p><span>原理</span></p><ul><li><span>添加之前检查容量是否足够，不够就进行扩容</span></li></ul></li></ul></li><li><p><span>扩容机制</span></p><ul><li><p><span>原理</span></p><ul><li><span>发生扩容时，新容量的数值是ArraysSupport.newLength()的返回值，也就是新的容量是旧容量加上旧容量值右移一位得到的，然后调用Arrays.copyOf()方法，返回新容量的数组。</span></li></ul></li><li><p><span>注意事项</span></p><ul><li><p><span>一个数右移一位的结果，等于这个数除以2^n的整数部分</span></p><ul><li><span>15*1.5=22.5，取22</span></li></ul></li><li><p><span>不一定是1.5倍</span></p></li><li><p><span>Arrays.copyOf()传入初始数组和新数组的长度，返回新数组，原始数组不变</span></p></li></ul></li></ul></li></ul></li><li><p><span>Vector</span></p><ul><li><p><span>定义</span></p><ul><li><span>线程安全的可变长数组</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>与ArrayList类似，只是操作时用synchronized锁，效率较低</span></li><li><span>扩容的大小是原有大小的2倍</span></li></ul></li></ul></li><li><p><span>LinkedList</span></p><ul><li><p><span>定义</span></p><ul><li><span>双向链表</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素</span></li><li><span>同时，定义内部类Node，作为LinkedList中保存数据的基本结构</span></li><li><span>Node类还定义了两个变量prev、next记录前后一个元素的位置</span></li></ul></li></ul></li></ul></li><li><p><span>Set</span></p><ul><li><p><span>定义</span></p><ul><li><span>不包含相同元素的集合，只能用equals判断是否两个对象是否相同</span></li></ul></li><li><p><span>HashSet</span></p><ul><li><p><span>定义</span></p><ul><li><span>按照Hash算法存储元素的Set集合</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍</span></li><li><span>hashmap</span></li></ul></li><li><p><span>添加原理</span></p><ul><li><p><span>1、当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。</span></p></li><li><p><span>2、需要遍历集合的所有元素，如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。</span></p></li><li><p><span>注意事项</span></p><ul><li><span>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功</span></li><li><span>复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算</span></li></ul></li></ul></li></ul></li><li><p><span>LinkedHashSet</span></p><ul><li><p><span>定义</span></p><ul><li><span>HashSet 的子类</span></li><li><span>根据元素的 hashCode 值来决定元素的存储位置</span></li><li><span>同时使用双向链表维护元素的次序</span></li><li><span>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能</span></li></ul></li></ul></li><li><p><span>TreeSet</span></p><ul><li><p><span>定义</span></p><ul><li><span>是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。</span></li><li><span>底层使用红黑树结构存储数据</span></li></ul></li><li><p><span>子主题 2</span></p></li></ul></li></ul></li><li><p><span>Queue</span></p></li></ul></li><li><p><span>Map</span></p><ul><li><p><span>定义</span></p><ul><li><span>保存具有映射关系的数据:key-value</span></li><li><span>key 用Set来存放，不允许重复(同一个 Map 对象所对应的类，须重写hashCode()和equals()方法)</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>key用Set存储，value用Collection存储</span></li></ul></li><li><p><span>Map.Entry</span></p><ul><li><p><span>定义</span></p><ul><li><span>Map的一个内部接口(静态内部类)，也是entrySet()的返回值类型</span></li><li><span>此接口为泛型，定义为Entry&lt;K,V&gt;。它表示Map中的一个实体（一个key-value对）</span></li></ul></li><li><p><span>方法</span></p><ul><li><span>getKey()</span></li><li><span>getValue()</span></li><li><span>setValue()</span></li></ul></li></ul></li><li><p><span>HashMap</span></p><ul><li><p><span>定义</span></p><ul><li><p><span>主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对</span></p></li><li><p><span>Node数组+Bucket(桶)</span></p></li><li><p><span>桶(Bucket)</span></p><ul><li><span>每个桶中存放一个Node对象，Node对象可以通过指针指向下一个元素</span></li></ul></li></ul></li><li><p><span>存储结构</span></p><ul><li><p><span>JDK7</span></p><ul><li><span>数组+链表结构(即为链地址法)</span></li></ul></li><li><p><span>JDK8</span></p><ul><li><span>数组+链表+红黑树</span></li></ul></li></ul></li><li><p><span>put原理</span></p><ul><li><p><span>假设添加entry1，首先计算entry1的哈希值，通过哈希值得到entry1在底层Entry[]数组存储的位置，如果位置上没有元素，直接添加。如果有元素，通过循环的方式遍历这个位置上存在的元素的key，与entry1的key的哈希值做比较，不同直接添加，哈希值相同就通过equals比较是否相同，不同就直接添加，相同就用entry1的value覆盖已存在的value值。</span></p></li><li><p><span>key相等</span></p><ul><li><span>两个 key 通过 equals() 方法返回 true，hashCode 值也相等。</span></li></ul></li><li><p><span>value相等</span></p><ul><li><span>两个 value 通过 equals() 方法返回 true</span></li></ul></li></ul></li><li><p><span>扩容机制</span></p><ul><li><p><span>相关参数</span></p><ul><li><p><span>加载因子</span></p><ul><li><p><span>定义</span></p><ul><li><span>加载因子 = 填入表中的元素个数 / 散列表的长度（Hash表的填满程度）</span></li></ul></li><li><p><span>说明</span></p><ul><li><span>加载因子越大，填满的元素越多，空间利用率越高，冲突的机会越大</span></li><li><span>加载因子越小，填满的元素越少，空间利用率越低，扩容rehash的次数增加</span></li></ul></li></ul></li><li><p><span>DEFAULT_INITIAL_CAPACITY</span></p><ul><li><span>HashMap的默认容量，16</span></li></ul></li><li><p><span>DEFAULT_LOAD_FACTOR</span></p><ul><li><span>：HashMap的默认加载因子</span></li></ul></li><li><p><span>MAXIMUM_CAPACITY </span></p><ul><li><span>HashMap的最大支持容量，2^30</span></li></ul></li><li><p><span>TREEIFY_THRESHOLD</span></p><ul><li><span>Bucket中链表长度大于该默认值，转化为红黑树</span></li></ul></li><li><p><span>UNTREEIFY_THRESHOLD</span></p><ul><li><span>：Bucket中红黑树存储的Node小于该默认值，转化为链表</span></li></ul></li><li><p><span>MIN_TREEIFY_CAPACITY</span></p><ul><li><span>桶中的Node被树化时最小的hash表容量</span></li></ul></li></ul></li><li><p><span>过程</span></p><ul><li><span>旧桶数组中的某个桶的外挂单链表是通过头插法插入新桶数组中的，并且原链表中的Entry结点并不一定仍然在新桶数组的同一链表。</span></li></ul></li></ul></li></ul></li><li><p><span>LinkedHashMap(HashMap)</span></p><ul><li><p><span>定义</span></p><ul><li><span>HashMap 的子类</span></li><li><span>在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序</span></li><li><span>与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致</span></li></ul></li></ul></li><li><p><span>TreeMap(SortedMap)</span></p><ul><li><p><span>定义</span></p><ul><li><span>底层使用红黑树结构存储数据</span></li></ul></li></ul></li><li><p><span>HashTable</span></p></li><li><p><span>Properties(HashTable)</span></p><ul><li><span>用于处理属性文件</span></li></ul></li></ul></li><li><p><span>Collections</span></p><ul><li><span>子主题 1</span></li><li><span>子主题 2</span></li></ul></li><li><p><span>ArraysList/Vector/LinkedList三者的异同？</span></p><ul><li><p><span>ArrayList和LinkedList的异同</span></p><ul><li><span>1、二者都线程不安全，相对线程安全的Vector，执行效率高</span></li><li><span>2、ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构</span></li><li><span>3、随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针</span></li><li><span>4、新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据</span></li></ul></li><li><p><span>ArrayList和Vector的区别</span></p><ul><li><span>Vector使用同步锁，线程安全，效率低下</span></li><li><span>ArrayList扩容是1.5倍，Vector扩容是2倍</span></li></ul></li></ul></li><li><p><span>ArrayList的底层？扩容机制？</span></p></li><li><p><span>为什么重写equals的方法的时候，必须重写hashCode方法？</span></p><ul><li><p><span>原因</span></p><ul><li><span>equals方法中需要hashCode实现方法中的一些参数</span></li></ul></li><li><p><span>规则</span></p><ul><li><p><span>重写equals</span></p><ul><li><span>重新定义类的实例对象相等的逻辑，比如id等</span></li></ul></li><li><p><span>重写hashCode</span></p><ul><li><span>同一个对象多次调用 hashCode() 方法应该返回相同的值</span></li><li><span>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode()方法的返回值也应相等。</span></li><li><span>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值</span></li></ul></li></ul></li></ul></li><li><p><span>HashMap的扩容时机？</span></p><ul><li><span>元素个数大于加载因子与默认容量的乘积时</span></li></ul></li><li><p><span>HashMap的树形化和链表化时机？</span></p><ul><li><p><span>树形化</span></p><ul><li><span>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。</span></li></ul></li><li><p><span>链表化</span></p><ul><li><span>当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表</span></li></ul></li></ul></li><li><p><span>HashMap加载因子为什么是0.75？</span></p><ul><li><span>1、时间和空间成本上寻求的一种折衷选择</span></li><li><span>2、使用随机哈希码，节点出现在hash桶中的频率遵循泊松分布</span></li><li><span>3、用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的，减少了哈希碰撞</span></li></ul></li><li><p><span>HashMap 的容量为什么是2的 n 次幂？</span></p><ul><li><p><span>加快hash计算</span></p><ul><li><span>rehash时的取余操作，通过hash % length == hash &amp; (length - 1)找到key所在哈希表的槽</span></li></ul></li><li><p><span>减少哈希碰撞</span></p><ul><li><span>HashMap中添加元素putVal()方法，向集合中添加元素时，会使用(n - 1) &amp; hash的计算方法来得出该元素在集合中的位置；</span></li><li><span>HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111这样形式的，这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞。</span></li></ul></li></ul></li><li><p><span>JDK1.8HashMap的变化？</span></p><ul><li><span>1、new HashMap()时数组长度为0，put()再创建16的数组</span></li><li><span>2、数组为Node类型，在jdk7中称为Entry类型</span></li><li><span>3、形成链表结构时，新添加的key-value对在链表的尾部</span></li><li><span>4、数组指定索引位置的链表长度&gt;8，且map中的数组的长度&gt; 64时才会使用红黑树进行存储</span></li></ul></li><li><p><span>hashCode的作用？</span></p><ul><li><span>hashCode是用来在散列存储结构中确定对象的存储地址的</span></li></ul></li><li><p><span>HashMap算法？</span></p><ul><li><p><span>int hash(key)</span></p><ul><li><p><span>h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></p><ul><li><p><span>符号运算</span></p><ul><li><p><span>^：按位异或运算，只要位不同结果为1，不然结果为0</span></p></li><li><blockquote><blockquote><blockquote><p><span>：无符号右移：左边高位补0</span></p></blockquote></blockquote></blockquote></li></ul></li><li><p><span>为什么使用^？</span></p><ul><li><span>异或运算能更好的保留各部分的特征</span></li></ul></li><li><p><span>为什么无符号右移16位？</span></p><ul><li><span>1、可以把高区与低区的二进制特征混合到低区</span></li><li><span>2、高区的16位很有可能会被数组槽位数的二进制码锁屏蔽，如果我们不做刚才移位异或运算，那么在计算槽位时将丢失高区特征</span></li><li><span>3、当两个哈希码很接近时，那么这高区的一点点差异就可能导致一次哈希碰撞</span></li></ul></li></ul></li><li><p><span>hashCode()方法，返回一个int类型的散列值</span></p></li></ul></li><li><p><span>putVal()</span></p><ul><li><p><span>i = (n - 1) &amp; hash</span></p><ul><li><span>添加元素时会计算数组的槽位</span></li><li><span>重新计算出的新哈希值在后面将会参与hashmap中数组槽位的计算</span></li></ul></li></ul></li></ul></li><li><p><span>HashMap与HashTable的区别？</span></p><ul><li><p><span>1、HashTable是线程安全的(synchronized)，HashMap 是非线程安全的</span></p></li><li><p><span>2、Hashtable 的 key 不能为 null，value 也不能为 null</span></p><ul><li><span>HashTable判断如果key、 value 为 null 就直接抛出空指针异常</span></li><li><span>HashMap如果key==null ，则其 hash=0 ；至于 value 是否为 null，根本没有判断过</span></li></ul></li><li><p><span>3、Hashtable 直接使用对象的 hash 值，取模运算需要做除法；HashMap将表的大小固定为2的n次幂，只需做位运算</span></p></li><li><p><span>4、Hashtable 的初始长度是 11，扩容为2n+1；HashMap 的初始长度为 16，扩容为2n</span></p></li><li><p><span>5、HashMap 继承的是 AbstractMap，并且 AbstractMap 也实现了 Map 接口。Hashtable 继承Dictionary类。</span></p></li></ul></li><li><p><span>关于映射关系的key是否可以修改？</span></p><ul><li><p><span>不要修改</span></p><ul><li><span>1、映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，提高性能。</span></li><li><span>2、如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上</span></li></ul></li></ul></li><li><p><span>HashMap 中的 key 可以使用任何类作为 key 吗？</span></p><ul><li><p><span>可以</span></p><ul><li><span>1、如果类重写了 equals 方法，它也应该重写 hashCode 方法</span></li><li><span>2、类的所有实例需要遵循与 equals 和 hashCode 相关的规则</span></li><li><span>3、如果一个类没有使用 equals，你不应该在 hashCode 中使用它</span></li><li><span>4、咱们自定义 key 类的最佳实践是使之为不可变的这样，hashCode 值可以被缓存起来，拥有更好的性能</span></li></ul></li></ul></li><li><p><span>为什么使用红黑树存储？</span></p><ul><li><p><span>解决哈希碰撞，提高查找效率</span></p></li><li><p><span>原因</span></p><ul><li><span>哈希值很多相同时，HashMap会退化为一个链表，时间复杂度从O(1)升到O(n)，get(key)时间开销更大。</span></li></ul></li></ul></li></ul><h3 id='java8新特性'><span>Java8新特性</span></h3><ul><li><p><span>Lambda 表达式</span></p><ul><li><span>函数式接口的实例</span></li><li><span>匿名内部类实现的都可以用Lambda</span></li></ul></li><li><p><span>函数式(Functional)接口</span></p><ul><li><p><span>定义</span></p><ul><li><span>只包含一个抽象方法的接口，称为函数式接口。</span></li></ul></li><li><p><span>分类</span></p><ul><li><p><span>Consumer</span><T><span>：消费</span></p><ul><li><span>void accept(T t)</span></li></ul></li><li><p><span>Supplier</span><T><span>：供给</span></p><ul><li><span>：T get()</span></li></ul></li><li><p><span>Function&lt;T, R&gt;：函数</span></p><ul><li><span>：R apply(T t)</span></li></ul></li><li><p><span>Predicate</span><T><span>：断定</span></p><ul><li><span>boolean test(T t)</span></li></ul></li></ul></li><li><p><span>操作</span></p><ul><li><p><span>@FunctionalInterface</span></p><ul><li><span>函数接口</span></li></ul></li></ul></li></ul></li><li><p><span>方法引用与构造器引用</span></p><ul><li><p><span>方法引用</span></p><ul><li><p><span>使用情况</span></p><ul><li><span>对象：：实例方法名</span></li><li><span>类：：静态方法名</span></li><li><span>类：：实例方法名</span></li></ul></li><li><p><span>要求</span></p><ul><li><span>实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的</span>
<span>方法的参数列表和返回值类型保持一致（类：：实例方法名除外）</span></li></ul></li></ul></li><li><p><span>子主题 2</span></p></li></ul></li><li><p><span>Stream流</span></p><ul><li><p><span>定义</span></p><ul><li><span>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</span></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>1、Stream 自己不会存储元素。</span></li><li><span>2、Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</span></li><li><span>3、Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</span></li></ul></li></ul></li><li><p><span>Stream 和 Collection 集合的区别？</span></p><ul><li><span>Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。</span></li><li><span>前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算</span></li></ul></li></ul><h2 id='juc'><span>JUC</span></h2><h3 id='相关概念'><span>相关概念</span></h3><ul><li><p><span>进程(Process)</span></p><ul><li><span>计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</span></li><li><span>在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位</span></li></ul></li><li><p><span>线程(Thread)</span></p><ul><li><p><span>定义</span></p><ul><li><span>操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</span></li><li><span>系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位</span></li></ul></li><li><p><span>分类</span></p><ul><li><p><span>用户线程</span></p><ul><li><span>平时用到的普通线程,自定义线程</span></li></ul></li><li><p><span>守护线程</span></p><ul><li><span>运行在后台,是一种特殊的线程,比如垃圾回收</span></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>当主线程结束后,用户线程还在运行,JVM 存活；如果没有用户线程,都是守护线程,JVM 结束</span></li></ul></li></ul></li></ul></li><li><p><span>并行与并发</span></p><ul><li><p><span>串行</span></p><ul><li><span>一次只能取得一个任务，并执行这个任务。</span></li></ul></li><li><p><span>并行</span></p><ul><li><span>可以同时取得多个任务，并同时去执行所取得的这些任务</span></li></ul></li><li><p><span>并发(concurrent)</span></p><ul><li><span>多个程序可以同时运行的现象，一个时间段内多个线程同时运行</span></li></ul></li></ul></li><li><p><span>线程的状态</span></p><ul><li><p><span>NEW(新建)</span></p><ul><li><span>新创建了一个线程对象，但还没有调用start()方法。</span></li></ul></li><li><p><span>RUNNABLE(准备就绪）</span></p><ul><li><span>Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”</span></li><li><span>调用start()方法或者资源完整等待CPU使用权</span></li></ul></li><li><p><span>BLOCKED（阻塞）</span></p></li><li><p><span>WAITING（不见不散）</span></p></li><li><p><span>TIMED_WAITING（过时不候）</span></p></li><li><p><span>TERMINATED(终结)</span></p></li></ul></li></ul><h3 id='不集合安全类'><span>不集合安全类</span></h3><ul><li><p><span>分类</span></p><ul><li><span>List</span></li><li><span>Map</span></li><li><span>Set</span></li></ul></li><li><p><span>解决方案</span></p><ul><li><p><span>List</span></p><ul><li><span>Vector类</span></li><li><span>CopyOnWriteArraysList类</span></li><li><span>Collections.synchrinizedList方法</span></li></ul></li><li><p><span>Set</span></p><ul><li><span>CopyOnWriteArraysSet类</span></li><li><span>Collections.synchrinizedSet方法</span></li></ul></li><li><p><span>Map</span></p><ul><li><span>Collections.synchrinizedMap方法</span></li><li><span>HashTable类</span></li><li><span>ConcurrentHashMap类</span></li></ul></li></ul></li><li><p><span>CopyOnWrite </span></p><ul><li><span>多个调用者共享一个内容，当有人想要修改内容的时候，就创建一个改内容的副本，对副本进行修改，然后再将原本的引用指向副本，完成内容的修改。</span></li><li><span>读写分离，写时复制出一个新的数组，完成插入、修改或者移除操作后将新数组赋值给array</span></li></ul></li></ul><h3 id='callable'><span>Callable</span></h3><ul><li><p><span>FutureTask</span></p><ul><li><p><span>定义</span></p><ul><li><span>可取消的异步任务，提供Future的基础实现，并实现了Runnable接口。</span></li></ul></li><li><p><span>继承了RunnableFuture接口，RunnableFuture又继承了Runnable类、Future类</span></p></li><li><p><span>可在后台运行</span></p></li></ul></li><li><p><span>实现方式</span></p><ul><li><p><span>线程管理</span></p><ul><li><span>FutureTask futureTask = new FutureTask(new Callable())</span></li></ul></li><li><p><span>线程池管理</span></p><ul><li><span>Executors.newFixedThreadPool().submit(new Callable()).get()</span></li></ul></li></ul></li></ul><h3 id='三大辅助类'><span>三大辅助类</span></h3><ul><li><p><span>减少计数 CountDownLatch</span></p><ul><li><p><span>原理</span></p><ul><li><span>阻塞当前线程，执行指定数量线程后再执行当前线程</span></li><li><span>当一个或多个线程调用 await 方法时，这些线程会阻塞，其他线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会阻塞），当计数器变为0时，await 方法阻塞的线程会被唤醒，继续执行。</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>1.CountDownLatch countDownLatch = new CountDownLatch(6);      </span><br/><span>2.new Thread(()-&gt;{countDownLatch.countDown()});</span>
<span>3.countDownLatch.await();</span></li></ul></li></ul></li><li><p><span>循环栅栏 CyclicBarrier</span></p><ul><li><p><span>原理</span></p><ul><li><span>线程阻塞的数量到达后再执行</span></li><li><span>构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()-&gt;{执行代码})</span>
<span>cyclicBarrier.await(); // 等待         </span></li></ul></li></ul></li><li><p><span>信号灯 Semaphore</span></p><ul><li><p><span>原理</span></p><ul><li><span>信号量机制，互斥资源访问</span></li><li><span>构造方法中传入的第一个参数是最大信号量（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证。使用 acquire 方法获得许可证，release 方法释放许可。</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>// 互斥资源数量（信号量机制）</span>
<span>Semaphore semaphore = new Semaphore(3);</span>
<span>semaphore.acquire(); // 得到资源(P操作)</span>
<span>semaphore.release(); // 释放资源(V操作)</span></li></ul></li></ul></li></ul><h3 id='读写锁'><span>读写锁</span></h3><ul><li><p><span>定义</span></p><ul><li><span>允许多个线程同时读取共享资源</span></li></ul></li><li><p><span>前提条件</span></p><ul><li><p><span>进入读锁</span></p><ul><li><span>没有其他线程的写锁</span></li><li><span>没有写请求, 或者有写请求，但调用线程和持有锁的线程是同一个(可重入锁)。</span></li></ul></li><li><p><span>进入写锁</span></p><ul><li><span>没有其他线程的读锁</span></li><li><span>没有其他线程的写锁</span></li></ul></li></ul></li><li><p><span>特性</span></p><ul><li><span>（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</span></li><li><span>（2）重进入：读锁和写锁都支持线程重进入。</span></li><li><span>（3）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</span></li></ul></li><li><p><span>总结</span></p><ul><li><p><span>小结</span></p><ul><li><span>在线程持有读锁的情况下，该线程不能取得写锁</span></li><li><span>在线程持有写锁的情况下，该线程可以继续获取读锁</span></li></ul></li><li><p><span>原因</span></p><ul><li><span>当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁。</span></li><li><span>而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。（锁降级）</span></li></ul></li></ul></li><li><p><span>实现</span></p><ul><li><span>ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span>
<span>readWriteLock.writeLock().lock(); // 写锁</span>
<span>readWriteLock.readLock().lock(); // 读锁</span></li></ul></li></ul><h3 id='阻塞队列'><span>阻塞队列</span></h3><ul><li><p><span>定义</span></p><ul><li><span>一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出</span></li><li><span>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列</span></li><li><span>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒</span></li></ul></li><li><p><span>Queue</span></p><ul><li><p><span>BlockingQueue(阻塞)</span></p><ul><li><p><span>ArrayBlockingQueue</span></p><ul><li><span>由数组结构组成的有界阻塞队列</span></li></ul></li><li><p><span>LinkedBlockingQueue</span></p><ul><li><span>由链表结构组成的有界（默认值为：integer.MAX_VALUE）阻塞队列</span></li></ul></li><li><p><span>SynchronousQueue</span></p><ul><li><span>不存储元素的阻塞队列，也即单个元素的队列。</span></li></ul></li><li><p><span>DelayQueue</span></p><ul><li><span>使用优先级队列实现的延迟无界阻塞队列</span></li></ul></li><li><p><span>PriorityBlockingQueue</span></p><ul><li><span>支持优先级排序的无界阻塞队列</span></li></ul></li><li><p><span>LinkedTransferQueue</span></p><ul><li><span>由链表组成的无界阻塞队列。</span></li></ul></li><li><p><span>LinkedBlockingDeque</span></p><ul><li><span>由链表组成的双向阻塞队列。</span></li></ul></li></ul></li><li><p><span>Deque(双端)</span></p></li><li><p><span>AbstractQueue(非阻塞)</span></p></li></ul></li><li><p><span>常用方法</span></p><ul><li><p><span>抛出异常</span></p><ul><li><span>add()、remove()、element()</span></li><li><span>队列满、空时抛出异常</span></li></ul></li><li><p><span>返回特殊值</span></p><ul><li><span>offer(e)、poll()、peek()</span></li><li><span>插入返回true/false，移除返回元素/null</span></li></ul></li><li><p><span>一直阻塞</span></p><ul><li><span>put(e)、take()</span></li><li><span>队列满、空时阻塞等待</span></li></ul></li><li><p><span>超时退出</span></p><ul><li><span>offer(e,time,unit)、poll(time,unit)</span></li><li><span>队列满时阻塞生产者，超时退出</span></li></ul></li></ul></li><li><p><span>实现</span></p><ul><li><span>ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span>
<span>blockingQueue.add(&quot;abc&quot;);</span>
<span>blockingQueue.remove();</span></li></ul></li></ul><h3 id='线程池'><span>线程池</span></h3><ul><li><p><span>定义</span></p></li><li><p><span>常用参数</span></p><ul><li><span>corePoolSize：线程池的核心线程数</span></li><li><span>maximumPoolSize：能容纳的最大线程数</span></li><li><span>keepAliveTime：空闲线程存活时间</span></li><li><span>unit：存活的时间单位</span></li><li><span>workQueue：存放提交但未执行任务的队列</span></li><li><span>threadFactory：创建线程的工厂类</span></li><li><span>handler：等待队列满后的拒绝策略</span></li></ul></li><li><p><span>创建方式</span></p><ul><li><p><span>Executors(不会采用)</span></p><ul><li><p><span>newCachedThreadPool()</span></p><ul><li><p><span>定义</span></p><ul><li><span>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>ExecutorService service2 = Executors.newCachedThreadPool();  // 不定个数线程</span></li></ul></li></ul></li><li><p><span>newFixedThreadPool()</span></p><ul><li><p><span>定义</span></p><ul><li><span>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>ExecutorService service1 = Executors.newFixedThreadPool(5);  // 固定个数线程</span></li></ul></li></ul></li><li><p><span>newSingleThreadExecutor()</span></p><ul><li><p><span>定义</span></p><ul><li><span>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>ExecutorService service = Executors.newSingleThreadExecutor();  // 单个线程</span></li></ul></li></ul></li><li><p><span>newScheduleThreadPool()</span></p><ul><li><span>线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池</span></li></ul></li><li><p><span>newWorkStealingPool()</span></p><ul><li><span>底层使用的是 ForkJoinPool 实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务。</span></li></ul></li></ul></li><li><p><span>new ThreadPoolExecutor()：自定义线程池</span></p></li></ul></li><li><p><span>四大拒绝策略</span></p><ul><li><p><span>AbortPolicy(ThreadPoolExecutor)</span></p><ul><li><span>丢弃任务并抛出RejectedExecutionException异常</span></li></ul></li><li><p><span>DiscardPolicy</span></p><ul><li><span>丢弃任务，但是不抛出异常</span></li></ul></li><li><p><span>DiscardOldestPolicy</span></p><ul><li><span>丢弃队列最前面(最老)的任务，添加新任务</span></li></ul></li><li><p><span>CallerRunsPolicy</span></p><ul><li><span>由调用线程处理该任务</span></li></ul></li></ul></li></ul><h3 id='jmm'><span>JMM</span></h3><ul><li><p><span>定义</span></p><ul><li><p><span>JAVA 内存模型（java memory model）</span></p></li><li><p><span>是一种抽象的概念，并不真实存在，它描述的是一组规则或者规范</span></p></li><li><p><span>规范了Java虚拟机与计算机内存是如何协同工作的</span></p><ul><li><span>一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量</span></li></ul></li></ul></li><li><p><span>关于同步的规定</span></p><ul><li><span>1、线程解锁前，必须把共享变量的值刷新回主内存</span></li><li><span>2、线程加锁前，必须读取主内存的最新值到自己的工作内存</span></li><li><span>3、加锁解锁是同一把锁</span></li></ul></li></ul><h3 id='volatile'><span>volatile</span></h3><ul><li><p><span>定义</span></p><ul><li><span>Java 虚拟机提供的轻量级的同步机制</span></li><li><span>用来保证数据的同步，也就是可见性(volatile 保证多线程间变量的可见性)</span></li></ul></li><li><p><span>特性</span></p><ul><li><p><span>1、保持可见性</span></p><ul><li><span>能够感知到主内存的变量的变化，例如死循环</span></li></ul></li><li><p><span>2、不保证原子性</span></p><ul><li><span>线程不安全</span></li></ul></li><li><p><span>3、禁止指令重排</span></p></li></ul></li><li><p><span>指令重排</span></p><ul><li><p><span>定义</span></p><ul><li><span>为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入的代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，并确保这一结果和顺序执行结果是一致的，但是这个过程并不保证各个语句计算的先后顺序和输入代码中的顺序一致。</span></li></ul></li><li><p><span>分类</span></p><ul><li><p><span>1、编译器优化的重排序</span></p><ul><li><p><span>不改变单线程程序语义</span></p><ul><li><span>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致</span></li></ul></li></ul></li><li><p><span>2、指令级并行的重排序</span></p><ul><li><p><span>不存在数据依赖性</span></p><ul><li><span>不同的程序指令之间的顺序是不允许进行交互的</span></li></ul></li></ul></li><li><p><span>3、内存系统的重排序</span></p><ul><li><span>处理器使用缓存和读/写缓冲区，看上去乱序执行</span></li></ul></li></ul></li></ul></li><li><p><span>内存屏障（Memory Barrier）</span></p><ul><li><p><span>定义</span></p><ul><li><span>又称为内存栅栏，一个CPU指令</span></li></ul></li><li><p><span>作用</span></p><ul><li><span>1、保证特定操作的执行顺序</span></li><li><span>2、保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。</span></li><li><span>3、强制刷出各种CPU的缓存数据，何CPU上的线程都能读取到这些数据的最新版本</span></li></ul></li></ul></li><li><p><span>禁止指令重排原理</span></p><ul><li><span>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</span></li></ul></li></ul><h3 id='单例模式'><span>单例模式</span></h3><ul><li><p><span>定义</span></p><ul><li><p><span>只能被实例化一次的类</span></p><ul><li><p><span>构造方法私有</span></p></li><li><p><span>静态方法返回实例</span></p><ul><li><span>防止对象被 new 出来</span></li></ul></li><li><p><span>实例化对象只有一个</span></p></li></ul></li></ul></li><li><p><span>类型</span></p><ul><li><p><span>饿汉式</span></p><ul><li><p><span>先把对象创建好，其他人来拿的时候直接返回已创建好的对象</span></p></li><li><p><span>不足</span></p><ul><li><span>容易造成资源上的浪费</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>private static final Hungry hungry = new Hungry(); //确保对象实例只有一个</span>
<span>private Hungry(){} //构造方法私有</span>
<span>public static Hungry getInstance() { //静态方法返回实例</span>
<span>return hungry;</span>
<span>}</span></li></ul></li></ul></li><li><p><span>懒汉式</span></p><ul><li><p><span>获取对象的时候再进行实例化</span></p></li><li><p><span>不足</span></p><ul><li><span>并发问题导致类被实例化多次</span></li></ul></li><li><p><span>实现</span></p><ul><li><span>private volatile static LazyMan lazyMan = null;  // 4.volatile避免指令重排</span>
<span>public static LazyMan getInstance() {</span>
<span>synchronized (LazyMan.class){  // 3.DCL懒汉式，保证线程安全</span>
<span>if (lazyMan == null){</span>
<span>    lazyMan = new LazyMan();</span>
<span>}</span>
<span>}</span>
<span>return lazyMan;</span>
<span>}</span></li></ul></li><li><p><span>存在的问题</span></p><ul><li><p><span>原因</span></p><ul><li><span>new操作不是原子操作，存在指令重排</span></li></ul></li><li><p><span>new 的三个步骤</span></p><ul><li><ol start='' ><li><span>分配对象内存空间</span></li></ol></li><li><ol start='2' ><li><span>执行构造方法初始化对象</span></li></ol></li><li><ol start='3' ><li><span>设置instance指向刚分配的内存地址，此时instance ！=null；</span></li></ol></li></ul></li><li><p><span>问题</span></p><ul><li><span>1、由于指令重排，导致A线程执行 lazyMan = new LazyMan();的时候，可能先执行了第三步（还没执行第二步）；</span></li><li><span>2、此时线程B又进来了，发现lazyMan已经不为空了，直接返回了lazyMan，并且后面使用了返回的lazyMan，由于线程A还没有执行第二步，导致此时lazyMan还不完整，容易出现问题。</span></li></ul></li><li><p><span>解决方案</span></p><ul><li><span>使用volatile修饰这个static的对象变量</span></li></ul></li></ul></li></ul></li></ul></li><li><p><span>防止单例被破坏</span></p><ul><li><p><span>1、DCL懒汉式，使用synchronized锁住Class对象</span></p></li><li><p><span>2、使用volatile避免指令重排</span></p></li><li><p><span>3、静态内部类</span></p><ul><li><span>public static Holder getInstance() {</span>
<span>return InnerClass.holder;</span>
<span>}</span>
<span>private static class InnerClass {</span>
<span>private static final Holder holder = new Holder();</span>
<span>}</span></li></ul></li><li><p><span>4、枚举类</span></p><ul><li><span>newInstance不能操作枚举类型</span></li></ul></li></ul></li></ul><h3 id='cas'><span>CAS</span></h3><ul><li><p><span>定义</span></p><ul><li><span>CompareAndSwap：比较并交换，是一条CPU并发原语（具有原子性的指令）。</span></li><li><span>判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</span></li></ul></li><li><p><span>Unsafe</span></p><ul><li><p><span>定义</span></p><ul><li><span>存在于 sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</span></li></ul></li><li><p><span>Unsafe类中的所有方法都是Native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。</span></p></li></ul></li><li><p><span>原理</span></p><ul><li><p><span>三个函数</span></p><ul><li><span>public final int incrementAndGet();  // 提供自增易用的方法，返回增加1后的值</span></li><li><span>public final boolean compareAndSet(int expect, int update);  // 额外提供的compareAndSet方法</span></li><li><span>public final int getAndAddInt(Object o,long offset, int delta);  // Unsafe 类的提供的方法</span></li></ul></li></ul></li><li><p><span>缺点</span></p><ul><li><span>循环时间长开销很大。</span></li><li><span>只能保证一个共享变量的原子操作</span></li><li><span>产生ABA问题</span></li></ul></li></ul><h3 id='aba问题'><span>ABA问题</span></h3><ul><li><p><span>定义</span></p><ul><li><span>如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前前线程的CAS操作无法分辨当前V值是否发生过变化。</span></li></ul></li><li><p><span>产生原因</span></p><ul><li><span>CAS需要取出内存中某时刻的数据并在当下时刻比较并交换，那么在这个时间差内会导致数据的变化。</span></li></ul></li><li><p><span>解决方案</span></p><ul><li><p><span>使用AtomicStampedReference类</span></p></li><li><p><span>实现</span></p><ul><li><span>new AtomicStampedReference&lt;&gt;(100,1);  //初始值 + 初始版本号(Stamp)</span>
<span>atomicStampedReference.compareAndSet(100, 101,</span>
<span>              atomicStampedReference.getStamp(),</span>
<span>              atomicStampedReference.getStamp()+1);  // 修改值 新值 当前版本号 新的版本号</span></li><li><span>每次CAS时检查当前version是否初始拿到的version相同，相同才进行修改</span></li></ul></li></ul></li></ul><h3 id='java锁'><span>Java锁</span></h3><ul><li><p><span>公平/非公平锁</span></p><ul><li><p><span>公平锁</span></p><ul><li><span>多个线程按照申请锁的顺序去获得锁，所有线程都在队列里排队</span></li></ul></li><li><p><span>非公平锁</span></p><ul><li><span>多个线程不按照申请锁的顺序去获得锁，而是同时直接去尝试获取锁（插队），获取不到（插队失败），再进入队列等待（失败则乖乖排队），如果能获取到（插队成功），就直接获取到锁。</span></li></ul></li><li><p><span>Synchronized非公平，RrantLock()默认非公平</span></p></li></ul></li><li><p><span>可重入锁(递归）</span></p><ul><li><p><span>定义</span></p><ul><li><span>同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法，获取锁的时候，在进入内层方法会自动获取锁。</span></li><li><span>可以避免死锁</span></li></ul></li></ul></li><li><p><span>自旋锁</span></p><ul><li><p><span>定义</span></p><ul><li><span>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</span></li><li><span>减少线程上下文切换的消耗，缺点是循环会消耗CPU。</span></li></ul></li></ul></li><li><p><span>死锁</span></p><ul><li><p><span>定义</span></p><ul><li><span>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</span></li><li><span>不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态</span></li></ul></li><li><p><span>四个必要条件</span></p><ul><li><span>互斥条件：一个资源每次只能被一个进程使用</span></li><li><span>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</span></li><li><span>不剥夺条件 : 进程已获得的资源，在末使用完之前，不能强行剥夺</span></li><li><span>循环等待条件 : 若干进程之间形成一种头尾相接的循环等待资源关系</span></li></ul></li><li><p><span>解决方案</span></p><ul><li><p><span>银行家算法</span></p><ul><li><p><span>定义</span></p><ul><li><span>子主题 1</span></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id='waitsleep的区别'><span>wait/sleep的区别？</span></h3><ul><li><span>1、sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都能调用</span></li><li><span>2、sleep 不会释放锁，它也不需要占用锁。wait 会释放锁，但调用它的前提是当前线程占有锁(即代码要在 synchronized 中)</span></li><li><span>3、它们都可以被 interrupted 方法中断</span></li></ul><h3 id='volatile为什么不能保证原子性'><span>volatile为什么不能保证原子性？</span></h3><ul><li><p><span>被volatile修饰的变量在读的时候可能会被多个线程读</span></p></li><li><p><span>例子</span></p><ul><li><span>线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞</span></li><li><span>线程B得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到缓存中，再刷入主存中</span></li><li><span>线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存</span></li></ul></li></ul><h3 id='volatile和synchronized区别'><span>volatile和synchronized区别</span></h3><ul><li><span>1、volatile仅能使用在变量级别,synchronized则可以使用在变量,方法</span></li><li><span>2、volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性</span></li></ul><h3 id='lock-和-synchronized的区别'><span>Lock 和 Synchronized的区别？</span></h3><ul><li><span>1、Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现</span></li><li><span>2、synchronized 在发生异常时，会自动释放线程占有的锁；Lock不会，容易造成死锁</span></li><li><span>3、Lock 可以让等待锁的线程响应中断，获取不到锁时结束线程；synchronized 等待的线程会一直等待下去，不能够响应中断</span></li><li><span>4、通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到</span></li><li><span>5、Lock 可以提高多个线程进行读操作的效率</span></li></ul><h3 id='copyonwritearraylist为什么并发安全且性能比vector好'><span>CopyOnWriteArrayList为什么并发安全且性能比Vector好？</span></h3><ul><li><span>Vector是增删改查方法都加了synchronized，CopyOnWriteArrayList只是增删改添加了</span></li></ul><h3 id='独占锁写锁共享锁读锁'><span>独占锁(写锁)、共享锁(读锁)</span></h3><ul><li><p><span>独占锁（写锁）</span></p><ul><li><span>指该锁一次只能被一个线程锁持有。对于ReentranrLock和 Synchronized 而言都是独占锁。</span></li></ul></li><li><p><span>共享锁(读锁)</span></p><ul><li><span>该锁可被多个线程所持有。ReentrantReadWriteLock。</span></li></ul></li></ul><h3 id='公平锁和非公平锁'><span>公平锁和非公平锁</span></h3><ul><li><p><span>公平锁</span></p><ul><li><span>多个线程按照申请锁的顺序去获得锁，所有线程都在队列里排队</span></li></ul></li><li><p><span>非公平锁</span></p><ul><li><span>多个线程不按照申请锁的顺序去获得锁，而是同时直接去尝试获取锁（插队），获取不到（插队失败），再进入队列等待（失败则乖乖排队），如果能获取到（插队成功），就直接获取到锁。</span></li></ul></li></ul><h3 id='为什么使用blockingqueue'><span>为什么使用BlockingQueue？</span></h3><ul><li><span>不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程</span></li></ul><h3 id='触发线程池的拒绝策略的时机'><span>触发线程池的拒绝策略的时机？</span></h3><ul><li><p><span>时机</span></p><ul><li><span>提交的任务数大于（workQueue.size() +maximumPoolSize ）</span></li></ul></li><li><p><span>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</span></p></li></ul><h3 id='线程池用哪个为什么不用executors'><span>线程池用哪个？为什么不用Executors？</span></h3><ul><li><p><span>使用自定义线程池</span></p></li><li><p><span>原因</span></p><ul><li><span>1、FixedThreadPool 和 SingleThreadExecutor 底层都是用LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，容易导致 OOM。</span></li><li><span>2、CacheedThreadPool和ScheduledThreaPoll允许创建线程的数量为Integer.MAX_VALUE，可能导致OOM。</span></li></ul></li></ul><h3 id='生产中如何设置合理参数'><span>生产中如何设置合理参数？</span></h3><h3 id='线程池的执行原理'><span>线程池的执行原理？</span></h3><ul><li><ol start='' ><li><span>在创建了线程池后，线程池中的线程数为零</span></li></ol></li><li><ol start='2' ><li><span>当调用 execute()方法添加一个请求任务时</span></li></ol><ul><li><span>2.1 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</span></li><li><span>2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</span></li><li><span>2.3 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</span></li><li><span>2.4 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</span></li></ul></li><li><ol start='3' ><li><span>当一个线程完成任务时，它会从队列中取下一个任务来执行</span></li></ol></li><li><ol start='4' ><li><span>当一个线程无事可做超过一定的时间（keepAliveTime）时</span></li></ol><ul><li><span>4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就会被停掉；</span></li><li><span>4.2 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</span></li></ul></li></ul><h3 id='线程是否越多越好'><span>线程是否越多越好？</span></h3><ul><li><p><span>计算为主的程序(CPU密集型程序)</span></p><ul><li><p><span>线程数等于cpu数</span></p></li><li><p><span>原因</span></p><ul><li><span>频繁的切换线程也是要消耗时间</span></li></ul></li></ul></li><li><p><span>个磁盘或网络为主的程序（IO密集型）</span></p><ul><li><p><span>线程数等于IO任务数</span></p></li><li><p><span>原因</span></p><ul><li><span>线程同时进行IO操作，减少IO等待的时间</span></li></ul></li></ul></li></ul><h3 id='atomicintegergetandincrement的自增--1如何实现'><span>atomicInteger.getAndIncrement()的自增 + 1如何实现？</span></h3><ul><li><span>调用了 unsafe.getAndAddInt(this, valueOffset, 1)</span></li></ul><h3 id='synchronized实现原理'><span>synchronized实现原理？</span></h3><ul><li><p><span>原理</span></p><ul><li><p><span>同步代码块</span></p><ul><li><span>1、synchronized关键字经过编译之后，会在同步代码块前后分别形成monitorenter和monitorexit字节码指令</span></li><li><span>2、在执行monitorenter指令的时候，首先尝试获取对象的锁</span></li><li><span>3、如果这个锁没有被锁定或者当前线程已经拥有了那个对象的锁，锁的计数器就加1，在执行monitorexit指令时会将锁的计数器减1，当减为0的时候就释放锁。</span></li><li><span>4、如果获取对象锁一直失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</span></li></ul></li><li><p><span>同步方法</span></p><ul><li><span>1、方法级的同步是隐式的，无须通过字节码指令来控制，通过方法常量池的方法表结构中的ACC_SYNCHRONIZED判断</span></li><li><span>2、当方法调用的时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否被设置</span></li><li><span>3、如果设置了，执行线程就要求先持有monitor对象，然后才能执行方法，最后当方法执行完（无论是正常完成还是非正常完成）时释放monitor对象。</span></li></ul></li><li><p><span>Synchronized在java对象头的实现</span></p><ul><li><span>改变一下标识位，并将指针指向monitor对象的起始地址</span></li></ul></li></ul></li><li><p><span>锁标志位</span></p><ul><li><p><span>无锁/偏向锁</span></p><ul><li><span>01</span></li></ul></li><li><p><span>轻量级锁</span></p><ul><li><span>00</span></li></ul></li><li><p><span>重量级锁</span></p><ul><li><span>10</span></li></ul></li><li><p><span>GC标记</span></p><ul><li><span>11</span></li></ul></li></ul></li><li><p><span>Monitor(监视器锁/管程)</span></p><ul><li><p><span>定义</span></p><ul><li><span>基于C++的ObjectMonitor类实现</span></li><li><span>理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象</span></li></ul></li><li><p><span>属性</span></p><ul><li><span>_owner：指向持有ObjectMonitor对象的线程</span></li><li><span>_WaitSet：存放处于wait状态的线程队列，即调用wait()方法的线程</span></li><li><span>_EntryList：存放处于等待锁block状态的线程队列</span></li><li><em><span>count：约为</span></em><span>WaitSet 和 _EntryList 的节点数之和</span></li><li><span>_cxq: 多个线程争抢锁，会先存入这个单向链表</span></li><li><span>_recursions: 记录重入次数</span></li></ul></li><li><p><span>工作机制</span></p><ul><li><span>1、当多个线程同时访问一段同步代码时，首先会进入 _EntryList 队列中</span></li><li><span>2、当某个线程获取到对象的Monitor后进入临界区域，并把Monitor中的 _owner 变量设置为当前线程，同时Monitor中的计数器 _count 加1。即获得对象锁。</span></li><li><span>3、若持有Monitor的线程调用 wait() 方法，将释放当前持有的Monitor，</span><em><span>owner变量恢复为null，</span></em><span>count自减1，同时该线程进入 _WaitSet 集合中等待被唤醒。</span></li><li><span>4、在</span><em><span>WaitSet 集合中的线程会被再次放到</span></em><span>EntryList 队列中，重新竞争获取锁。</span></li><li><span>5、若当前线程执行完毕也将释放Monitor并复位变量的值，以便其他线程进入获取锁</span></li></ul></li></ul></li></ul><h3 id='synchronized早期效率低'><span>synchronized早期效率低？</span></h3><ul><li><span>监视器锁(monitor)是依赖于底层的操作系统的Mutex Lock来实现的</span></li><li><span>操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间</span></li></ul><h3 id='对象的内存布局'><span>对象的内存布局</span></h3><ul><li><p><span>对象头</span></p><ul><li><p><span>运行时元数据(Mark Word)</span></p><ul><li><p><span>哈希值（HashCode）</span></p></li><li><p><span>GC分代年龄</span></p></li><li><p><span>锁状态标志</span></p><ul><li><span>轻量级锁定、重量级锁定、GC标记、可偏向</span></li></ul></li><li><p><span>线程持有的锁</span></p></li><li><p><span>偏向线程ID</span></p></li><li><p><span>偏向时间戳</span></p></li><li><p><span>----如果是数组，还需要记录数组的长度</span></p></li></ul></li><li><p><span>类型指针</span></p><ul><li><span>指向类元数据InstanceClass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</span></li></ul></li></ul></li><li><p><span>实例数据</span></p><ul><li><span>对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承的和本身的)</span></li></ul></li><li><p><span>对齐填充</span></p><ul><li><span>非必须，占位符作用</span></li></ul></li></ul><h3 id='锁消除和锁粗化'><span>锁消除和锁粗化</span></h3><ul><li><p><span>锁消除</span></p><ul><li><span>JIT编译器在编译的时候，进行逃逸分析。分析synchronized锁对象是不是只可能被一个线程加锁，不存在其他线程来竞争加锁的情况。这时就可以消除该锁了，提升执行效率。</span></li><li><span>编译就不用加入monitorenter和monitorexit指令</span></li></ul></li><li><p><span>锁粗化</span></p><ul><li><span>JIT编译时，发现一段代码中频繁的加锁释放锁，会将前后的锁合并为一个锁，避免频繁加锁释放锁。</span></li></ul></li></ul><h3 id='synchronized优化锁优化'><span>synchronized优化(锁优化)</span></h3><ul><li><p><span>偏向锁</span></p><ul><li><p><span>定义</span></p><ul><li><span>如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构</span></li><li><span>当这个线程再次请求锁时，无需再做任何同步操作，直接获取锁</span></li></ul></li><li><p><span>引入原因</span></p><ul><li><span>1、在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得</span></li><li><span>2、减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价</span></li><li><span>3、在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。</span></li><li><span>4、轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。</span></li></ul></li><li><p><span>执行流程</span></p><ul><li><p><span>获取锁</span></p><ul><li><span>1、检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01</span></li><li><span>2、若为可偏向状态，则测试线程ID是否为当前线程ID</span></li><li><span>3、如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID</span></li><li><span>4、通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块。</span></li><li><span>5、如果线程ID是当前线程ID，执行同步代码块</span></li></ul></li><li><p><span>释放锁</span></p><ul><li><span>1、暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定状态</span></li><li><span>2、撤销偏向锁，恢复到无锁状态(01)或者轻量级锁的状态；</span></li><li><span>不会主动释放偏向锁，等待其它线程竞争(全局安全点释放)</span></li></ul></li></ul></li><li><p><span>场景</span></p><ul><li><span>没有锁竞争</span></li><li><span>只有一个线程执行同步块</span></li></ul></li></ul></li><li><p><span>轻量级锁</span></p><ul><li><p><span>定义</span></p><ul><li><span>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁</span></li></ul></li><li><p><span>引入原因</span></p><ul><li><span>1、对绝大部分的锁，在整个同步周期内都不存在竞争，可能是交替获取锁然后执行</span></li><li><span>2、在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗(多指时间消耗)</span></li></ul></li><li><p><span>执行流程</span></p><ul><li><p><span>获取锁</span></p><ul><li><span>1、判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝(Displaced Mark Word)</span></li><li><span>2、JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00，执行同步操作。</span></li><li><span>3、如果当前对象有锁，或者竞争锁失败</span></li><li><span>4、判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块</span></li><li><span>5、否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</span></li></ul></li><li><p><span>释放锁</span></p><ul><li><span>1、取出在获取轻量级锁保存在Displaced Mark Word中的数据；</span></li><li><span>2、用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功。</span></li><li><span>3、如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程</span></li></ul></li></ul></li><li><p><span>场景</span></p><ul><li><span>多个线程同一时间访问同一锁</span></li><li><span>线程交替执行同步块</span></li></ul></li></ul></li><li><p><span>自旋锁</span></p><ul><li><p><span>定义</span></p><ul><li><span>让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁</span></li></ul></li><li><p><span>原理</span></p><ul><li><span>执行一段无意义的循环即可（自旋），超过自定义的时间挂起线程</span></li></ul></li><li><p><span>自适应自旋锁</span></p><ul><li><p><span>定义</span></p><ul><li><span>自旋的次数不固定</span></li><li><span>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</span></li></ul></li><li><p><span>原理</span></p><ul><li><span>线程如果自旋成功了，那么下次自旋的次数会更加多(JVM认为这次自旋很可能成功，允许次数增加)</span></li><li><span>如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</span></li></ul></li></ul></li></ul></li><li><p><span>总执行流程</span></p><ul><li><p><span>1、当一个线程(假设叫A线程)想要获得锁时，首先检查对象头中(Mark Word)的锁标志</span></p><ul><li><p><span>如果是偏向锁</span></p><ul><li><span>检查对象头中的偏向线程id是否指向A线程，如果是，则直接执行同步代码块</span></li></ul></li><li><p><span>如果不是</span></p><ul><li></li></ul></li></ul></li><li><p><span>2、如果不是，使用cas操作将替换对象头中的偏向线程id</span></p><ul><li><p><span>如果成功</span></p><ul><li><span>直接执行同步代码块</span></li></ul></li></ul></li><li><p><span>3、如果cas替换失败，说明其它线程(B线程)已经拥有偏向锁，需要释放这个偏向锁</span></p></li><li><p><span>4、B线程运行到全局安全点后，暂停该线程，检查它的状态</span></p><ul><li><p><span>如果处于不活动或者已经退出同步代码块</span></p><ul><li><span>原持有偏向锁的线程释放锁，A线程尝试使用cas操作将替换对象头中的偏向线程id</span></li></ul></li></ul></li><li><p><span>5、如果处于活动状态，升级为轻量级锁</span></p></li><li><p><span>6、在B线程的栈中分配锁记录，拷贝对象头中的MarkWord到锁记录中，然后将MarkWord改为指向B线程，同时将对象头中的锁标志信息改为轻量级锁的00,然后唤醒B线程。(从安全点执行)</span></p></li><li><p><span>7、由于锁升级为轻量级锁, A线程也进行相同的操作（升级轻量级锁），因为此时B线程拥有锁，因此, A线程自旋。如果自旋一定次数内成功获得锁，那么A线程获得轻量级锁，执行同步代码块</span></p></li><li><p><span>8、若自旋后仍未获得锁，A升级为重量级锁，将对象头中的锁标志信息改为重量级的10，同时阻塞。</span></p></li><li><p><span>9、B线程在释放锁的时候，使用cas将MarkWord中的信息替换，成功，则表示无竞争(这个时候还是轻量级锁, A线程可能正在自旋中)，直接释放</span></p></li><li><p><span>10、失败(因为这个时候锁已经膨胀)，那么释放之 后唤醒被挂起的线程(在这个例子中，也就是A)。</span></p></li></ul></li></ul><h2 id='jvm'><span>JVM</span></h2><h3 id='定义'><span>定义</span></h3><ul><li><span>二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。</span></li><li><span>运行在操作系统之上的，它与硬件没有直接的交互</span></li></ul><h3 id='特点'><span>特点</span></h3><ul><li><span>一次编译，到处运行</span></li><li><span>自动内存管理</span></li><li><span>自动垃圾回收功能</span></li></ul><h3 id='类加载子系统'><span>类加载子系统</span></h3><ul><li><p><span>定义</span></p><ul><li><span>负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识</span></li><li><span>只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</span></li><li><span>class file加载到JVM中，被称为DNA元数据模板，放在方法区</span></li></ul></li><li><p><span>类加载过程</span></p><ul><li><p><span>加载</span></p><ul><li><span>1、通过一个类的全限定名获取定义此类的二进制字节流</span></li><li><span>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</span></li><li><span>3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</span></li></ul></li><li><p><span>链接</span></p><ul><li><p><span>验证(Verify)</span></p><ul><li><p><span>目的</span></p><ul><li><span>确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</span></li></ul></li><li><p><span>分类</span></p><ul><li><span>文件格式验证</span></li><li><span>元数据验证</span></li><li><span>字节码验证</span></li><li><span>符号引用验证</span></li></ul></li></ul></li><li><p><span>准备(Prepare)</span></p><ul><li><p><span>目的</span></p><ul><li><span>为类变量分配内存并且设置该类变量的默认初始值，即零值</span></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化。</span></li><li><span>不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</span></li></ul></li></ul></li><li><p><span>解析(Resolve)</span></p><ul><li><p><span>定义</span></p><ul><li><span>将常量池内的符号引用转换为直接引用的过程</span></li></ul></li></ul></li></ul></li><li><p><span>初始化</span></p><ul><li><p><span>定义</span></p><ul><li><span>初始化阶段就是执行类构造器法</span><clinit><span>（）的过程。</span></li></ul></li><li><p><span>也就是按顺序给静态代码块中的变量和静态变量(类变量)赋予真实值的过程.</span></p></li></ul></li></ul></li><li><p><span>类加载器</span></p><ul><li><p><span>定义</span></p><ul><li><span>将class文件加载到JVM中</span></li></ul></li><li><p><span>分类</span></p><ul><li><p><span>启动类加载器（引导类加载器，Bootstrap ClassLoader）</span></p><ul><li><span>加载Java的核心库，提供JVM自身需要的类。</span></li></ul></li><li><p><span>扩展类加载器（Extension ClassLoader）</span></p><ul><li><span>指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。</span></li></ul></li><li><p><span>应用程序类加载器（系统类加载器，AppClassLoader）</span></p><ul><li><span>程序中默认的类加载器</span></li><li><span>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</span></li></ul></li><li><p><span>用户自定义类加载器</span></p></li></ul></li></ul></li><li><p><span>双亲委派机制</span></p><ul><li><p><span>定义</span></p><ul><li><span>Java虚拟机对class文件采用的是按需加载，加载某个类的class文件时，Java虚拟机采用的是双亲委派模式</span></li></ul></li><li><p><span>工作原理</span></p><ul><li><span>1、如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</span></li><li><span>2、如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</span></li><li><span>3、如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</span></li></ul></li><li><p><span>优势</span></p><ul><li><p><span>避免类的重复加载</span></p></li><li><p><span>保护程序安全，防止核心API被随意修改</span></p><ul><li><span>自定义String类</span></li></ul></li></ul></li></ul></li><li><p><span>沙箱安全机制</span></p><ul><li><span>就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏</span></li><li><span>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。</span></li></ul></li><li><p><span>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</span></p></li></ul><h3 id='程序计数器pc'><span>程序计数器(PC)</span></h3><ul><li><p><span>定义</span></p><ul><li><span>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</span></li></ul></li><li><p><span>原理</span></p><ul><li><span>PC存放的是下一条指令的地址，执行引擎从pc中取出指令执行后，PC+1,看起来pc像是存放当前线程执行的位置一样(执行引擎读取后执行才+1)。</span></li></ul></li><li><p><span>为什么PC寄存器存储字节码指令地址？</span></p><ul><li><span>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</span></li></ul></li><li><p><span>为什么PC寄存器记录当前线程的执行地址？</span></p><ul><li><span>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</span></li></ul></li><li><p><span>PC寄存器为什么被设定为私有的？</span></p><ul><li><span>CPU会不停地做任务切换，为了能够准确地记录各个线程正在执行的当前字节码指令地址，每一个线程都分配一个PC寄存器。</span></li></ul></li></ul><h3 id='虚拟机栈'><span>虚拟机栈</span></h3><ul><li><p><span>定义</span></p><ul><li><span>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用</span></li><li><span>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</span></li></ul></li><li><p><span>栈帧</span></p><ul><li><p><span>定义</span></p><ul><li><span>虚拟机栈的存储单位</span></li><li><span>每个方法对应一个栈帧</span></li><li><span>是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</span></li><li><span>保存指向对象或数组在堆中位置的引用</span></li></ul></li><li><p><span>结构</span></p><ul><li><p><span>局部变量表</span></p><ul><li><p><span>定义</span></p><ul><li><span>一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</span></li><li><span>局部变量表所需的容量大小是在编译期确定下来的</span></li></ul></li><li><p><span>变量槽(Slot)</span></p><ul><li><p><span>定义</span></p><ul><li><span>局部变量表的存储单元</span></li></ul></li><li><p><span>4KB</span></p></li></ul></li><li><p><span>重复利用</span></p><ul><li><span>Slot可以重复利用，如果一个局部变量超过了作用域，那么在其作用域后新申明的局部变量可能会复用过期局部变量的槽位，节省资源。</span></li><li><span>{ int a = 1; }</span>
<span>int b = 2;   // b可能会复用a的槽位</span></li></ul></li></ul></li><li><p><span>操作数栈</span></p><ul><li><p><span>定义</span></p><ul><li><span>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</span></li></ul></li><li><p><span>作用</span></p><ul><li><span>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</span></li></ul></li></ul></li><li><p><span>动态链接</span></p><ul><li><p><span>定义</span></p><ul><li><span>栈帧内部一个指向运行时常量池中该栈帧所属方法的引用</span></li></ul></li><li><p><span>作用</span></p><ul><li><span>将符号引用转换为调用方法直接引用</span></li></ul></li></ul></li><li><p><span>方法返回地址</span></p><ul><li><p><span>定义</span></p><ul><li><span>存放调用该方法的pc寄存器的值。</span></li></ul></li><li><p><span>返回值</span></p><ul><li><p><span>正常退出</span></p><ul><li><span>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</span></li></ul></li><li><p><span>异常退出</span></p><ul><li><span>返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息</span></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p><span>方法调用</span></p><ul><li><p><span>将符号引用转换为调用方法的直接引用与方法的绑定机制相关</span></p></li><li><p><span>链接</span></p><ul><li><p><span>静态链接</span></p><ul><li><span>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变</span></li></ul></li><li><p><span>动态链接</span></p><ul><li><span>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用</span></li></ul></li></ul></li><li><p><span>绑定机制</span></p><ul><li><span>早期绑定</span></li><li><span>晚期绑定</span></li></ul></li></ul></li></ul><h3 id='本地方法接口'><span>本地方法接口</span></h3><ul><li><p><span>本地方法</span></p><ul><li><span>一个Native Methodt是一个Java调用非Java代码的接囗。</span></li></ul></li><li><p><span>作用</span></p><ul><li><span>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</span></li></ul></li><li><p><span>为什么使用Native Method？</span></p><ul><li><p><span>与Java环境外的交互</span></p><ul><li><span>需要与一些底层系统，如操作系统或某些硬件交换信息</span></li></ul></li><li><p><span>与操作系统的交互</span></p><ul><li><span>依赖于一底层系统的支持</span></li></ul></li></ul></li></ul><h3 id='本地方法栈'><span>本地方法栈</span></h3><ul><li><p><span>定义</span></p><ul><li><span>用于管理本地方法的调用</span></li><li><span>C语言实现</span></li><li><span>允许被实现成固定或者是可动态扩展的内存大小（与虚拟机栈内存溢出相同）</span></li></ul></li><li><p><span>过程</span></p><ul><li><span>Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</span></li></ul></li></ul><h3 id='堆'><span>堆</span></h3><ul><li><p><span>定义</span></p><ul><li><span>(几乎)所有的对象实例以及数组都应当在运行时分配在堆上</span></li><li><span>是JVM管理的最大一块内存空间</span></li><li><span>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</span></li><li><span>JVM启动时创建，空间大小已确认</span></li></ul></li><li><p><span>内部结构</span></p><ul><li><p><span>新生代</span></p><ul><li><span>Eden(伊甸园)区</span></li><li><span>Survivor区</span></li></ul></li><li><p><span>老年代</span></p></li><li><p><span>元空间</span></p></li></ul></li><li><p><span>对象分配过程</span></p></li><li><p><span>GC类型</span></p><ul><li><p><span>部分收集（Partial GC）</span></p><ul><li><p><span>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</span></p></li><li><p><span>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。</span></p><ul><li><span>CMS GC独有</span></li></ul></li><li><p><span>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集</span></p><ul><li><span>G1 GC独有</span></li></ul></li></ul></li><li><p><span>整堆收集（FullGC）</span></p><ul><li><span>收集整个java堆和方法区的垃圾收集。</span></li></ul></li></ul></li><li><p><span>子主题 5</span></p><ul><li><p><span>Minor GC</span></p><ul><li><p><span>定义</span></p><ul><li><span>发生在新生代的GC</span></li></ul></li><li><p><span>触发机制</span></p><ul><li><span>1、年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存）。</span></li><li><span>2、会触发STW</span></li></ul></li></ul></li><li><p><span>Major GC</span></p><ul><li><p><span>定义</span></p><ul><li><span>发生在老年代的GC，对象从老年代消失</span></li></ul></li><li><p><span>触发机制</span></p><ul><li><span>老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC。</span></li><li><span>发生一次Major GC，至少有一次YGC，MajorGC速度比YGC慢很多</span></li><li><span>如果Major GC后，内存还不足，就报OOM了</span></li></ul></li></ul></li><li><p><span>Full GC</span></p><ul><li><p><span>定义</span></p><ul><li><span>收集整个java堆和方法区的垃圾收集。</span></li></ul></li><li><p><span>触发机制</span></p><ul><li><span>1、调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行</span></li><li><span>2、老年代空间不足</span></li><li><span>3、方法区空间不足</span></li><li><span>4、通过Minor GC后进入老年代的平均大小大于老年代的可用内存</span></li><li><span>5、Eden区，from区向to区复制时，对象大小大于to区的可用内存，把对象转存到老年代时老年代的可用内存大小小于该对象大小。</span></li></ul></li></ul></li></ul></li><li><p><span>内存分配策略(对象晋升规则)</span></p><ul><li><span>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁。当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代。</span></li><li><span>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</span></li></ul></li><li><p><span>TLAB(Thread Local Allocation Buffer)</span></p><ul><li><p><span>定义</span></p><ul><li><span>每个线程分配的一个私有缓存区域，它包含在Eden空间内</span></li></ul></li><li><p><span>本质</span></p><ul><li><span>TLAB的本质其实是三个指针管理的区域：start，top 和 end，每个线程都会从Eden分配一块空间，</span></li><li><span>例如说100KB，作为自己的TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住eden里的一块空间不让其它线程来这里分配。</span></li><li><span>指针碰撞</span></li></ul></li></ul></li><li><p><span>逃逸分析</span></p><ul><li><p><span>定义</span></p><ul><li><span>分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</span></li><li><span>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</span></li><li><span>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</span></li></ul></li><li><p><span>优化</span></p><ul><li><p><span>栈上分配</span></p><ul><li><p><span>定义</span></p><ul><li><span>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</span></li></ul></li><li><p><span>场景</span></p><ul><li><span>成员变量赋值、方法返回值、实例引用传递</span></li></ul></li></ul></li><li><p><span>同步省略(锁消除)</span></p><ul><li><span>动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。</span></li><li><span>同步是保证线程安全执行的一种策略</span></li></ul></li><li><p><span>标量替换(分离对象)</span></p><ul><li><p><span>标量</span></p><ul><li><span>一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</span></li></ul></li><li><p><span>聚合量</span></p><ul><li><span>可以分解的数据，Java中的对象就是聚合量</span></li></ul></li><li><p><span>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</span></p></li></ul></li></ul></li></ul></li></ul><h3 id='方法区元空间'><span>方法区(元空间)</span></h3><ul><li><p><span>定义</span></p><ul><li><span>看作是一块独立于Java堆的内存空间</span></li><li><span>大小决定了系统可以保存多少个类</span></li><li><span>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</span></li><li><span>JVM启动时创建，内存物理不连续，逻辑连续</span></li></ul></li><li><p><span>存储内容</span></p><ul><li><p><span>类型信息</span></p><ul><li><span>完整有效名称（全名=包名.类名）</span></li><li><span>直接父类的完整有效名</span></li><li><span>修饰符（public，abstract，final的某个子集）</span></li><li><span>直接接口的一个有序列表</span></li></ul></li><li><p><span>域(Filed)信息</span></p><ul><li><span>域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</span></li></ul></li><li><p><span>方法（Method）信息</span></p><ul><li><span>所有方法的方法名称、返回类型、参数的数量和类型、修饰符、字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）、异常表（abstract和native方法除外）</span></li></ul></li><li><p><span>静态变量</span></p></li><li><p><span>全局变量</span></p><ul><li><span>static final 进行修饰</span></li></ul></li><li><p><span>JIT代码缓存</span></p></li><li><p><span>运行时常量池</span></p></li></ul></li><li><p><span>常量池</span></p><ul><li><span>Class文件的一部分，包括各种字面量(数值量和字符串值)和对类型、域和方法的符号引用。</span></li><li><span>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</span></li></ul></li><li><p><span>运行时常量池</span></p><ul><li><span>方法区的一部分</span></li><li><span>包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址</span></li></ul></li><li><p><span>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</span></p></li></ul><h3 id='对象的实例化'><span>对象的实例化</span></h3><ul><li><p><span>创建对象的方式</span></p><ul><li><span>1、new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</span></li><li><span>2、Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</span></li><li><span>3、Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</span></li><li><span>4、使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</span></li><li><span>5、使用序列化：序列化一般用于Socket的网络传输</span></li><li><span>6、第三方库 Objenesis</span></li></ul></li><li><p><span>创建对象的步骤</span></p><ul><li><p><span>1、判断对象对应的类是否加载、链接、初始化</span></p><ul><li><span>首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。</span></li><li><span>如果没有，那么在双亲委派模式下，使用当前类加载器加载对应.class文件，找到进行类加载，生成Class对象；没有找抛出ClassNoyFoundException异常。</span></li></ul></li><li><p><span>2、为对象分配内存</span></p><ul><li><p><span>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间(4KB)。</span></p></li><li><p><span>内存规整</span></p><ul><li><span>指针碰撞</span></li></ul></li><li><p><span>内存不规整</span></p><ul><li><span>虚拟表需要维护一个列表，空闲列表分配</span></li></ul></li></ul></li><li><p><span>3、处理并发问题</span></p><ul><li><span>采用CAS配上失败重试保证更新的原子性</span></li><li><span>在Eden区给每个线程分配一块区域</span></li></ul></li><li><p><span>4、初始化分配到的内存</span></p><ul><li><span>属性的默认初始化</span></li><li><span>显示初始化</span></li><li><span>代码块中的初始化</span></li><li><span>构造器初始化</span></li><li><span>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</span></li></ul></li><li><p><span>5、设置对象的对象头</span></p><ul><li><span>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息(gc分代年龄)、锁信息(偏向锁)等数据存储在对象的对象头中。</span></li></ul></li><li><p><span>6、执行init方法进行初始化</span></p><ul><li><span>初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</span></li></ul></li></ul></li><li><p><span>对象的实例化过程</span></p><ul><li><span>1、加载类元信息</span></li><li><span>2、为对象分配内存</span></li><li><span>3、处理并发问题</span></li><li><span>4、属性的默认初始化（零值初始化）</span></li><li><span>5、设置对象头信息</span></li><li><span>6、属性的显示初始化、代码块中初始化、构造器中初始化</span></li></ul></li><li><p><span>对象的内存布局</span></p><ul><li><p><span>对象头</span></p><ul><li><p><span>运行时元数据(Mark Word)</span></p><ul><li><p><span>哈希值（HashCode）</span></p></li><li><p><span>GC分代年龄</span></p></li><li><p><span>锁状态标志</span></p><ul><li><span>轻量级锁定、重量级锁定、GC标记、可偏向</span></li></ul></li><li><p><span>线程持有的锁</span></p></li><li><p><span>偏向线程ID</span></p></li><li><p><span>偏向时间戳</span></p></li></ul></li><li><p><span>类型指针</span></p><ul><li><span>指向类元数据InstanceClass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</span></li></ul></li></ul></li><li><p><span>实例数据</span></p><ul><li><span>对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承的和本身的)</span></li></ul></li><li><p><span>对齐填充</span></p><ul><li><span>非必须，占位符作用</span></li></ul></li></ul></li><li><p><span>对象的访问定位</span></p><ul><li><p><span>定义</span></p><ul><li><span>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</span></li></ul></li><li><p><span>方式</span></p><ul><li><p><span>句柄访问</span></p><ul><li><span>栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池，通过句柄池的指针访问对象类型数据、实例数据。</span></li></ul></li><li><p><span>直接指针</span></p><ul><li><span>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</span></li></ul></li></ul></li></ul></li><li><p><span>指针碰撞</span></p><ul><li><span>所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离。</span></li><li><span>使用压缩算法的垃圾回收器使用</span></li></ul></li><li><p><span>空闲分区列表</span></p><ul><li><span>一个列表，记录哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</span></li></ul></li></ul><h3 id='执行引擎'><span>执行引擎</span></h3><ul><li><p><span>定义</span></p><ul><li><span>将字节码指令解释/编译为对应平台上的本地机器指令</span></li><li><span>包括 解释器、及时编译器、垃圾回收器</span></li><li><span>充当了将高级语言翻译为机器语言的译者</span></li><li><span>所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</span></li></ul></li><li><p><span>工作流程</span></p><ul><li><span>执行引擎取出PC寄存器中的执行的指令地址，执行对应的字节码</span></li><li><span>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</span></li><li><span>方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中(栈帧中操作数栈)的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</span></li></ul></li><li><p><span>字节码</span></p><ul><li><span>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</span></li><li><span>为了实现特定软件运行和软件环境、与硬件环境无关</span></li><li><span>通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</span></li></ul></li><li><p><span>解释器</span></p><ul><li><p><span>定义</span></p><ul><li><span>Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</span></li><li><span>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</span></li></ul></li><li><p><span>构成</span></p><ul><li><span>Interpreter模块：实现了解释器的核心功能</span></li><li><span>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</span></li></ul></li><li><p><span>流程</span></p><ul><li><span>将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</span></li></ul></li></ul></li><li><p><span>JIT编译器</span></p><ul><li><p><span>定义</span></p><ul><li><span>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</span></li></ul></li><li><p><span>分类</span></p><ul><li><p><span>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器</span></p><ul><li><span>C1编译器会对字节码进行简单和可靠的优化，耗时短</span></li></ul></li><li><p><span>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。</span></p><ul><li><span>C2进行耗时较长的优化，以及激进优化</span></li></ul></li></ul></li><li><p><span>流程</span></p><ul><li><span>使用即时编译技术（JIT，Just In Time）将字节码(方法)编译成机器码后再执行</span></li></ul></li><li><p><span>C1 和 C2编译器不同的优化策略</span></p><ul><li><p><span>c1</span></p><ul><li><span>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</span></li><li><span>去虚拟化：对唯一的实现樊进行内联</span></li><li><span>冗余消除：在运行期间把一些不会执行的代码折叠掉</span></li></ul></li><li><p><span>c2</span></p><ul><li><span>标量替换：用标量值代替聚合对象的属性值</span></li><li><span>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</span></li><li><span>同步消除：清除同步操作，通常指synchronized</span></li></ul></li></ul></li></ul></li><li><p><span>HotSpot JVM执行方式</span></p><ul><li><span>1、当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。</span></li><li><span>2、并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</span></li></ul></li><li><p><span>热点探测技术</span></p><ul><li><p><span>定义</span></p><ul><li><span>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令</span></li></ul></li><li><p><span>基于计数器的热点探测</span></p><ul><li><p><span>方法调用计数器</span></p><ul><li><p><span>作用</span></p><ul><li><span>统计方法的调用次数</span></li></ul></li><li><p><span>具体流程</span></p><ul><li><span>1、当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。</span></li><li><span>2、如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。</span></li><li><span>3、如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</span></li></ul></li></ul></li><li><p><span>回边计数器</span></p><ul><li><p><span>作用</span></p><ul><li><span>统计循环体执行的循环次数</span></li><li><span>目的就是为了触发OSR编译</span></li></ul></li><li><p><span>具体流程</span></p><ul><li><span>1、遇到回边指令时，检查该指令是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行</span></li><li><span>2、如果不存在已被编译过的版本，则将此方法的回边计数器计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。</span></li><li><span>3、如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。调整回边计数器的值，进行解释执行；反之直接解释执行。</span></li></ul></li></ul></li></ul></li><li><p><span>热点衰减</span></p><ul><li><span>如果不做任何设置，，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。</span></li><li><span>当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半。</span></li><li><span>-XX:-UseCounterDecay 来关闭热度衰减</span></li><li><span>-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒</span></li></ul></li><li><p><span>回边指令</span></p><ul><li><span>字节码中遇到控制流向后跳转的指令</span></li></ul></li><li><p><span>OSR(栈上替换)</span></p><ul><li><p><span>定义</span></p><ul><li><span>方法编译为本地机器指令，存储在方法区中</span></li><li><span>在程序执行过程中，动态地替换掉 Java 方法栈桢，从而使得程序能够在非方法入口处进行解释执行和编译后的代码之间的切换。</span></li></ul></li></ul></li><li><p><span>提交代码编译请求，生成编译后的机器码后并不是马上执行，而是保存到方法区，下次再执行</span></p></li></ul></li><li><p><span>分层编译策略</span></p><ul><li><span>程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</span></li></ul></li></ul><h3 id='垃圾回收'><span>垃圾回收</span></h3><ul><li><p><span>概述</span></p><ul><li><p><span>垃圾</span></p><ul><li><span>在运行程序中没有任何指针指向的对象</span></li></ul></li><li><p><span>Java垃圾回收机制</span></p><ul><li><span>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</span></li><li><span>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题</span></li><li><span>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</span></li></ul></li><li><p><span>早期gc</span></p><ul><li><span>使用new关键字进行内存申请，并使用delete关键字进行内存释放</span></li></ul></li></ul></li><li><p><span>垃圾回收算法</span></p><ul><li><p><span>标记阶段</span></p><ul><li><p><span>定义</span></p><ul><li><span>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。</span></li></ul></li><li><p><span>方式</span></p><ul><li><p><span>引用计数算法</span></p><ul><li><p><span>定义</span></p><ul><li><span>对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况</span></li></ul></li><li><p><span>原理</span></p><ul><li><span>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</span></li></ul></li><li><p><span>优缺点</span></p><ul><li><p><span>优点</span></p><ul><li><span>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性</span></li></ul></li><li><p><span>缺点</span></p><ul><li><span>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销</span></li><li><span>无法解决循环引用</span></li></ul></li></ul></li><li><p><span>循环引用</span></p><ul><li><span>假设两个对象相互引用，有一个对象被一个外部对象引用，如果这个引用消失了，就只有两个对象互相引用，无法使计数器置0</span></li></ul></li></ul></li><li><p><span>可达性分析算法</span></p><ul><li><p><span>定义</span></p><ul><li><span>根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达</span></li></ul></li><li><p><span>原理</span></p><ul><li><span>1、内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链。</span></li><li><span>2、如果目标对象没有任何引用链相连，不可达，为垃圾回收对象。</span></li><li><span>3、只有能够被根对象集合直接或者间接连接的对象才是存活对象</span></li></ul></li><li><p><span>GC Roots</span></p><ul><li><p><span>定义</span></p><ul><li><span>一组必须活跃的引用</span></li></ul></li><li><p><span>分类</span></p><ul><li><p><span>虚拟机栈中引用的对象</span></p><ul><li><span>各个线程被调用的方法中使用到的参数、局部变量</span></li></ul></li><li><p><span>方法区中常量引用的对象</span></p><ul><li><span>字符串常量池（string Table）里的引用</span></li></ul></li><li><p><span>所有被同步锁synchronized持有的对象</span></p></li><li><p><span>Java虚拟机内部的引用</span></p><ul><li><span>基本数据类型对应的Class对象</span></li></ul></li><li><p><span>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存</span></p></li><li><p><span>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象</span></p><ul><li><span>Java类的引用类型静态变量</span></li></ul></li></ul></li><li><p><span>总结</span></p><ul><li><span>除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析。</span></li></ul></li><li><p><span>导致STW</span></p><ul><li><span>1、分析工作必须在一个能确保一致性的快照中进行</span></li><li><span>2、如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</span></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p><span>finalization(对象终止)机制</span></p><ul><li><p><span>定义</span></p><ul><li><span>允许开发人员提供对象被销毁之前的自定义处理逻辑。</span></li><li><span>垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</span></li><li><span>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放，比如关闭文件、套接字和数据库连接等。</span></li><li><span>finalize()只会被调用一次。</span></li></ul></li><li><p><span>判断对象是否回收过程</span></p><ul><li><p><span>如果对象objA到GC Roots没有引用链，则进行第一次标记。</span></p></li><li><p><span>进行筛选，判断此对象是否有必要执行finalize()方法</span></p><ul><li><p><span>1、如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过。</span></p><ul><li><span>对象不可达</span></li></ul></li><li><p><span>2、如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</span></p></li><li><p><span>3、如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。</span></p><ul><li><span>对象可达</span></li></ul></li></ul></li></ul></li><li><p><span>不要主动调用某个对象的finalize方法,应该交给垃圾回收机制调用？</span></p><ul><li><p><span>在finalize（）时可能会导致对象复活</span></p></li><li><p><span>一个糟糕的finalize（）会严重影响Gc的性能</span></p></li><li><p><span>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定</span></p><ul><li><span>优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</span></li></ul></li></ul></li></ul></li><li><p><span>清除阶段</span></p><ul><li><p><span>定义</span></p><ul><li><span>执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</span></li></ul></li><li><p><span>方式</span></p><ul><li><p><span>标记一清除算法（Mark-Sweep）</span></p><ul><li><p><span>执行过程</span></p><ul><li><p><span>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world）</span></p></li><li><p><span>标记</span></p><ul><li><p><span>Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</span></p><ul><li><span>标记的是引用的对象，不是垃圾！！</span></li></ul></li></ul></li><li><p><span>清除</span></p><ul><li><span>Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</span></li></ul></li></ul></li><li><p><span>清除</span></p><ul><li><span>并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。</span></li><li><span>下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</span></li></ul></li><li><p><span>缺点</span></p><ul><li><span>标记清除算法的效率不算高</span></li><li><span>在进行GC的时候，需要停止整个应用程序，用户体验较差</span></li><li><span>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表，产生额外的空间消耗</span></li></ul></li></ul></li><li><p><span>复制算法（copying）</span></p><ul><li><p><span>原理</span></p><ul><li><span>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活(可达)对象复制到未被使用的内存块中</span></li><li><span>之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</span></li></ul></li><li><p><span>优缺点</span></p><ul><li><p><span>优点</span></p><ul><li><span>没有标记和清除过程，实现简单，运行高效</span></li><li><span>复制过去以后保证空间的连续性，不会出现“碎片”问题</span></li></ul></li><li><p><span>缺点</span></p><ul><li><span>需要两倍的内存空间。</span></li><li><span>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间</span></li></ul></li></ul></li><li><p><span>场景</span></p><ul><li><span>复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</span></li></ul></li></ul></li><li><p><span>标记-压缩算法（Mark-Compact）</span></p><ul><li><p><span>执行过程</span></p><ul><li><span>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</span></li><li><span>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</span></li></ul></li><li><p><span>优缺点</span></p><ul><li><p><span>优点</span></p><ul><li><span>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</span></li><li><span>消除了复制算法当中，内存减半的高额代价</span></li></ul></li><li><p><span>缺点</span></p><ul><li><span>从效率上来说，标记-整理算法要低于复制算法</span></li><li><span>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</span></li><li><span>移动过程中，需要全程暂停用户应用程序。即：STW</span></li></ul></li></ul></li></ul></li></ul></li><li><p><span>标清和标整的区别</span></p><ul><li><span>标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。</span></li><li><span>标整存活对象重新按照内存地址依次排序，要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，比空闲列表开销小</span></li></ul></li></ul></li><li><p><span>分代收集算法</span></p><ul><li><p><span>定义</span></p><ul><li><span>不同生命周期的对象可以采取不同的收集方式</span></li></ul></li><li><p><span>场景</span></p><ul><li><span>新生代——复制</span></li><li><span>老年代——标清，标整</span></li></ul></li></ul></li><li><p><span>增量收集算法</span></p><ul><li><p><span>定义</span></p><ul><li><span>让垃圾收集线程和应用程序线程交替执行</span></li><li><span>增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</span></li><li><span>增量收集算法的基础仍是传统的标记-清除和复制算法。</span></li></ul></li><li><p><span>原理</span></p><ul><li><span>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</span></li></ul></li><li><p><span>优缺点</span></p><ul><li><span>能减少系统的停顿时间</span></li><li><span>因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</span></li></ul></li></ul></li><li><p><span>分区算法</span></p><ul><li><p><span>定义</span></p><ul><li><span>将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间</span></li><li><span>不是整个堆空间，从而减少一次GC所产生的停顿。</span></li></ul></li><li><p><span>子主题 2</span></p></li></ul></li></ul></li><li><p><span>相关概念</span></p><ul><li><p><span>System.gc()的理解</span></p></li><li><p><span>内存溢出(OOM)</span></p><ul><li><p><span>定义</span></p><ul><li><span>没有空闲内存的情况：说明Java虚拟机的堆内存不够</span></li><li><span>程序在申请内存时，没有足够的内存空间供其使用</span></li></ul></li><li><p><span>原因</span></p><ul><li><p>&nbsp;</p><ul><li><span>Java虚拟机的堆内存设置不够。</span></li><li><span>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</span></li></ul></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间</span></li><li><span>也不是在任何情况下垃圾收集器都会被触发的</span></li><li><span>我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</span></li></ul></li></ul></li><li><p><span>内存泄露</span></p><ul><li><p><span>定义</span></p><ul><li><span>程序在申请内存后，无法释放已申请的内存空间</span></li><li><span>有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题。</span></li></ul></li><li><p><span>例子</span></p><ul><li><p><span>单例模式</span></p><ul><li><span>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</span></li></ul></li><li><p><span>一些提供close的资源未关闭导致内存泄漏</span></p><ul><li><span>数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close</span></li></ul></li></ul></li></ul></li><li><p><span>STW(stop the world)</span></p><ul><li><span>Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉。</span></li><li><span>可达性分析(GC Roots)会出现</span></li></ul></li><li><p><span>垃圾回收的并行与并发</span></p><ul><li><p><span>并行（Parallel）</span></p><ul><li><p><span>多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态(STW)</span></p><ul><li><span>ParNew、Parallel Scavenge、Parallel old</span></li></ul></li></ul></li><li><p><span>串行（Serial）</span></p><ul><li><p><span>同一时刻只能执行垃圾收集线程或用户线程(STW)</span></p><ul><li><span>Serial、Serial Old</span></li></ul></li></ul></li><li><p><span>并发（Concurrent）</span></p><ul><li><span>用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）,垃圾回收线程在执行时不会停顿用户程序的运行。</span></li><li><span>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上</span></li><li><span>CMS，G1</span></li></ul></li></ul></li><li><p><span>安全点与安全区域</span></p><ul><li><p><span>安全点(Safepoint)</span></p><ul><li><p><span>定义</span></p><ul><li><span>程序执行到某个位置时处于安全状态，可以进行GC</span></li></ul></li><li><p><span>方式</span></p><ul><li><p><span>抢先式中断(丢弃)</span></p><ul><li><span>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点</span></li></ul></li><li><p><span>主动式中断</span></p><ul><li><span>设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</span></li></ul></li></ul></li><li><p><span>作用</span></p><ul><li><span>保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。</span></li></ul></li></ul></li><li><p><span>安全区域(Safe Region)</span></p><ul><li><p><span>定义</span></p><ul><li><span>在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。</span></li></ul></li><li><p><span>执行流程</span></p><ul><li><span>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程。</span></li><li><span>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</span></li></ul></li><li><p><span>产生原因</span></p><ul><li><span>程序“不执行”的时候，例如线程处于sleep-状态或Blocked 状态，这时候线程无法响应JVM的中断请求。</span></li></ul></li></ul></li></ul></li><li><p><span>四大引用</span></p><ul><li><p><span>强引用</span></p><ul><li><p><span>定义</span></p><ul><li><span>使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</span></li><li><span>强引用的对象是可触及(GC Roots)的，垃圾收集器就永远不会回收掉被引用的对象。</span></li></ul></li><li><p><span>特点</span></p><ul><li><span>强引用可以直接访问目标对象</span></li><li><span>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</span></li><li><span>强引用可能导致内存泄漏。</span></li></ul></li></ul></li><li><p><span>软引用</span></p><ul><li><p><span>定义</span></p><ul><li><span>用来描述一些还有用，但非必需的对象</span></li><li><span>在系统将要发生内存溢出异常前，会把软引用关联对象列进回收范围之中进行第二次回收。</span></li><li><span>如果这次回收还没有足够的内存，才会抛出内存溢出异常。</span></li></ul></li><li><p><span>特点</span></p><ul><li><span>当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</span></li></ul></li></ul></li><li><p><span>弱引用</span></p><ul><li><p><span>定义</span></p><ul><li><span>用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止</span></li></ul></li><li><p><span>可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</span></p></li></ul></li><li><p><span>虚引用</span></p><ul><li><p><span>定义</span></p><ul><li><span>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</span></li></ul></li><li><p><span>目的</span></p><ul><li><p><span>唯一目的在于跟踪垃圾回收过程</span></p><ul><li><span>在这个对象被收集器回收时收到一个系统通知</span></li></ul></li></ul></li><li><p><span>特点</span></p><ul><li><span>无法获取数据</span></li><li><span>必须和引用队列一起使用</span></li></ul></li></ul></li></ul></li></ul></li><li><p><span>垃圾回收器</span></p><ul><li><p><span>分类</span></p><ul><li><p><span>线程数</span></p><ul><li><span>串行</span></li><li><span>并行</span></li></ul></li><li><p><span>工作模式</span></p><ul><li><p><span>并发式</span></p></li><li><p><span>独占式</span></p><ul><li><span>一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</span></li></ul></li></ul></li><li><p><span>碎片处理方式</span></p><ul><li><span>压缩式</span></li><li><span>非压缩式</span></li></ul></li></ul></li><li><p><span>性能指标</span></p><ul><li><p><span>分类</span></p><ul><li><p><span>吞吐量</span></p><ul><li><p><span>运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）。</span></p><ul><li><span>重点</span></li></ul></li></ul></li><li><p><span>垃圾收集开销</span></p><ul><li><span>吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</span></li></ul></li><li><p><span>暂停时间</span></p><ul><li><p><span>执行垃圾收集时，程序的工作线程被暂停的时间。</span></p><ul><li><span>重点</span></li></ul></li></ul></li><li><p><span>收集频率</span></p><ul><li><span>相对于应用程序的执行，收集操作发生的频率。</span></li></ul></li><li><p><span>内存占用</span></p><ul><li><span>Java堆区所占的内存大小。</span></li></ul></li><li><p><span>快速</span></p><ul><li><span>一个对象从诞生到被回收所经历的时间。</span></li></ul></li></ul></li><li><p><span>吞吐量vs暂停时间</span></p><ul><li><span>以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收</span></li><li><span>以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降</span></li><li><span>高吞吐与低暂停互相矛盾</span></li></ul></li></ul></li><li><p><span>7大回收器</span></p><ul><li><p><span>分类</span></p><ul><li><p><span>分代</span></p><ul><li><p><span>新生代收集器</span></p><ul><li><span>Serial、ParNew、Paralle1 Scavenge</span></li></ul></li><li><p><span>老年代收集器</span></p><ul><li><span>Serial old、Parallel old、CMS</span></li></ul></li><li><p><span>整堆收集器</span></p><ul><li><span>G1</span></li></ul></li></ul></li><li><p><span>线程数</span></p><ul><li><p><span>串行回收器</span></p><ul><li><span>Serial、Serial old</span></li></ul></li><li><p><span>并行回收器</span></p><ul><li><span>ParNew、Parallel Scavenge、Parallel old</span></li></ul></li><li><p><span>并发回收器</span></p><ul><li><span>CMS、G11</span></li></ul></li></ul></li></ul></li><li><p><span>配对</span></p></li><li><p><span>Serial</span></p><ul><li><p><span>定义</span></p><ul><li><span>复制算法 + 串行回收 + &quot;stop-the-World&quot;机制的方式执行内存回收</span></li><li><span>HotSpot中client模式下的默认新生代垃圾收集器。</span></li></ul></li></ul></li><li><p><span>Serial Old</span></p><ul><li><p><span>定义</span></p><ul><li><span>标志-压缩算法 + 串行回收 + &quot;stop-the-World&quot;机制的方式执行内存回收</span></li><li><span>运行在Client模式下默认的老年代的垃圾回收器</span></li></ul></li><li><p><span>Server模式</span></p><ul><li><span>与新生代的Parallel scavenge配合使用</span></li><li><span>作为老年代CMS收集器的后备垃圾收集方案</span></li></ul></li></ul></li><li><p><span>ParNew</span></p><ul><li><p><span>定义</span></p><ul><li><span>复制算法+ 并行回收 + &quot;stop-the-World&quot;机制</span></li><li><span>运行在Server模式下新生代的默认垃圾收集器</span></li></ul></li><li><p><span>场景</span></p><ul><li><span>对于新生代，回收次数频繁，使用并行方式高效。</span></li><li><span>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</span></li></ul></li></ul></li><li><p><span>Parallel(吞吐量优先)</span></p><ul><li><p><span>Parallel Scavenge</span></p><ul><li><p><span>定义</span></p><ul><li><span>复制算法+ 并行回收 + &quot;stop-the-World&quot;机制</span></li><li><span>目标则是达到一个可控制的吞吐量（Throughput）</span></li></ul></li></ul></li><li><p><span>Parallel Old</span></p><ul><li><p><span>定义</span></p><ul><li><span>标记-压缩算法 + 并行回收 + &quot;stop-the-World&quot;机制</span></li></ul></li></ul></li><li><p><span>一般用于Server模式</span></p></li></ul></li><li><p><span>CMS(低延迟)</span></p><ul><li><p><span>定义</span></p><ul><li><span>标记-清除算法 + 并发回收 + &quot;stop-the-World&quot;机制</span></li><li><span>第一次实现了让垃圾收集线程与用户线程同时工作</span></li><li><span>尽可能缩短垃圾收集时用户线程的停顿时间</span></li></ul></li><li><p><span>执行过程</span></p><ul><li><p><span>初始标记阶段</span></p><ul><li><span>程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停</span></li><li><span>仅仅只是标记出GCRoots能直接关联到的对象</span></li></ul></li><li><p><span>并发标记阶段</span></p><ul><li><span>从Gc Roots的直接关联对象开始遍历整个对象图</span></li><li><span>不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</span></li></ul></li><li><p><span>重新标记阶段</span></p><ul><li><span>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</span></li></ul></li><li><p><span>并发清除阶段</span></p><ul><li><span>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</span></li><li><span>不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</span></li></ul></li></ul></li><li><p><span>优缺点</span></p><ul><li><p><span>优点</span></p><ul><li><span>并发收集</span></li><li><span>低延迟</span></li><li><span>若干次Gc后进行一次碎片整理</span></li></ul></li><li><p><span>缺点</span></p><ul><li><p><span>会产生内存碎片</span></p><ul><li><span>标记-清除算法产生</span></li></ul></li><li><p><span>CMS收集器对CPU资源非常敏感</span></p><ul><li><span>CMS占用一部分线程，在并发阶段会降低总吞吐量，使程序变慢</span></li></ul></li><li><p><span>CMS收集器无法处理浮动垃圾</span></p><ul><li><span>并发标记阶段产生的垃圾对象无法被标记</span></li></ul></li></ul></li></ul></li><li><p><span>浮动垃圾</span></p><ul><li><span>并发标记阶段产生的新的垃圾对象，无法对其进行标记</span></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。</span></li><li><span>CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。</span></li><li><span>CMS运行期间预留的内存无法满足程序需要，临时启用Serial old收集器来重新进行老年代的垃圾收集，停顿时间加长。</span></li></ul></li></ul></li><li><p><span>G1(区域化分代式)</span></p><ul><li><p><span>定义</span></p><ul><li><span>一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</span></li><li><span>一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</span></li><li><span>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。</span></li><li><span>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</span></li><li><span>保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</span></li></ul></li><li><p><span>场景</span></p><ul><li><span>面向服务端应用，针对具有大内存、多处理器的机器。</span></li></ul></li><li><p><span>优缺点</span></p><ul><li><p><span>优点</span></p><ul><li><p><span>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</span></p></li><li><p><span>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</span></p></li><li><p><span>分代收集</span></p><ul><li><span>可以工作在老年代和年轻代</span></li></ul></li><li><p><span>空间整合</span></p><ul><li><span>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。</span></li><li><span>Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。</span></li></ul></li><li><p><span>可预测的停顿时间模型（软实时soft real-time）</span></p><ul><li><span>能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</span></li></ul></li></ul></li><li><p><span>缺点</span></p><ul><li><span>在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</span></li><li><span>在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势</span></li></ul></li></ul></li><li><p><span>分区Region(化整为零)</span></p><ul><li><p><span>定义</span></p><ul><li><span>所有的Region大小相同，且在JVM生命周期内不会被改变。</span></li><li><span>将整个Java堆划分成约2048个大小相同的独立Region块，</span></li><li><span>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。</span></li><li><span>region通过指针碰撞分配空间</span></li></ul></li><li><p><span>Humongous(H区)</span></p><ul><li><span>主要用于存储大对象，如果超过1.5个region，就放到H。</span></li></ul></li><li><p><span>注意事项</span></p><ul><li><span>如果设置了Region数量，那么Region大小就不是固定的，但是大小肯定是2的幂次方，并且在1~32M之间；</span></li><li><span>如果设置了Region大小，那么Region数量就不是固定的，但是肯定是2048附近；</span></li></ul></li></ul></li><li><p><span>回收过程</span></p><ul><li><p><span>Remembered Set(记忆集)</span></p><ul><li><p><span>解决的问题</span></p><ul><li><p><span>一个对象被不同区域引用的问题</span></p></li><li><p><span>判断对象存活时，是否需要扫描整个Java堆才能保证准确？</span></p></li><li><p><span>老年代引用新生代，回收新生代也不得不同时扫描老年代？</span></p><ul><li><span>会降低MinorGC的效率</span></li></ul></li></ul></li><li><p><span>解决方案</span></p><ul><li><p><span>1、每个Region都有一个对应的Remembered Set</span></p></li><li><p><span>2、每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作。</span></p></li><li><p><span>3、检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region</span></p><ul><li><span>其他收集器：检查老年代对象是否引用了新生代对象</span></li></ul></li><li><p><span>4、如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</span></p></li><li><p><span>5、进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</span></p></li></ul></li></ul></li><li><p><span>dirty card queue(脏卡表)</span></p><ul><li><span>Reset更新需要线程同步，所以开销会很大，因此不能实时更新</span></li><li><span>把引用对象被其他对象引用的关系放在一个脏卡表队列中，</span></li><li><span>当年轻代回收的时候会进行STW，所以我们也正好把脏卡表队列中的值更新到Rset中，</span></li><li><span>保证Rset中的数据是准确的</span></li><li><span>记录可能存在老年代到新生代引用的内存区域</span></li></ul></li><li><p><span>执行流程</span></p><ul><li><p><span>年轻代GC（Young GC）</span></p><ul><li><p><span>扫描根</span></p><ul><li><span>static变量指向的对象，正在执行的方法调用链条上的局部变量等，连同RSet记录的外部引用作为扫描存活对象的入口。</span></li></ul></li><li><p><span>更新RSet</span></p><ul><li><span>处理dirty card queue（见备注）中的card，更新RSet。</span></li></ul></li><li><p><span>处理RSet</span></p><ul><li><span>识别被老年代对象指向的Eden中的对象为存活对象</span></li></ul></li><li><p><span>复制对象</span></p><ul><li><p><span>对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段</span></p><ul><li><span>Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到old区中空的内存分段</span></li><li><span>如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</span></li></ul></li></ul></li><li><p><span>处理引用</span></p><ul><li><span>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。</span></li></ul></li></ul></li><li><p><span>老年代并发标记过程（Concurrent Marking）</span></p><ul><li><p><span>初始标记阶段</span></p><ul><li><span>标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC</span></li></ul></li><li><p><span>根区域扫描</span></p><ul><li><span>G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。</span></li><li><span>这一过程必须在youngGC之前完成。进行young GC的时候会移动Survivor区，移动之后就找不到哪些老年代对象是可达的了。</span></li></ul></li><li><p><span>并发标记</span></p><ul><li><span>在整个堆中进行并发标记（和应用程序并发执行），可能会被YGC打断。</span></li><li><span>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性</span></li></ul></li><li><p><span>再次标记</span></p><ul><li><p><span>由于应用程序持续进行，需要修正上一次的标记结果</span></p><ul><li><span>采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</span></li></ul></li></ul></li><li><p><span>独占清理</span></p><ul><li><span>计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域</span></li></ul></li><li><p><span>并发清理阶段</span></p><ul><li><span>识别并清理完全空闲的区域</span></li></ul></li></ul></li><li><p><span>混合回收（Mixed GC）</span></p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id='子主题-29'><span>子主题 29</span></h3><p><span>### </span></p><h3 id='类发生初始化的时机'><span>类发生初始化的时机？</span></h3><ul><li><p><span>类的主动引用</span></p><ul><li><span>1、当虚拟机启动，先初始化main方法所在的类</span></li><li><span>2、new一个类的对象</span></li><li><span>3、调用类的静态成员（除了final常量）和静态方法</span></li><li><span>4、使用java.lang.reflect包的方法对类进行反射调用</span></li><li><span>5、当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</span></li></ul></li><li><p><span>类的被动引用</span></p><ul><li><p><span>1、当访问一个静态域时，只有真正声明这个域的类才会被初始化</span></p><ul><li><span>当通过子类引用父类的静态变量，不会导致子类初始化，只是存放了指向这个变量的引用</span></li></ul></li><li><p><span>2、通过数组定义类引用，不会触发此类的初始化</span></p><ul><li><span>只是定义了一个变量名和开辟了一块空间</span></li></ul></li><li><p><span>3、引用常量不会触发此类的初始化</span></p><ul><li><span>常量在链接阶段就存入调用类的常量池中了</span></li></ul></li></ul></li></ul><h3 id='加载class文件的方式'><span>加载class文件的方式？</span></h3><ul><li><span>从本地系统中直接加载</span></li><li><span>从zip压缩包中读取，成为日后jar、war格式的基础</span></li><li><span>通过网络获取，典型场景：Web Applet</span></li><li><span>从加密文件中获取，典型的防Class文件被反编译的保护措施</span></li></ul><h3 id='为什么要把符号引用转为直接引用'><span>为什么要把符号引用转为直接引用？</span></h3><ul><li><span>class文件加载时还没有进入内存，没有变量和方法的真实地址，只能用符号代替，真正用时才进行转换</span></li></ul><h3 id='为什么要自定义类加载器'><span>为什么要自定义类加载器？</span></h3><ul><li><p><span>隔离加载类</span></p><ul><li><span>一个工程引用多个框架时，某些类的路径、类名一致，产生冲突</span></li></ul></li><li><p><span>修改类加载的方式</span></p><ul><li><span>自定义加载逻辑</span></li></ul></li><li><p><span>扩展加载源</span></p><ul><li><span>指定方式加载类库(通过数据库、电视机的机顶盒等等来扩展加载源)</span></li></ul></li><li><p><span>防止源码泄漏</span></p><ul><li><span>可以对字节码文件进行加密，只要自定义类加载器才能解密</span></li></ul></li></ul><p><span>### </span></p><h3 id='java堆heap跟栈stack的区别'><span>Java堆(Heap)跟栈(Stack)的区别？</span></h3><ul><li><span>1、栈是运行时的单位，而堆是存储的单位</span></li><li><span>2、栈解决程序的运行问题，即程序如何执行，或者说如何处理数据</span></li><li><span>3、堆解决的是数据存储的问题，即数据怎么放，放哪里</span></li></ul><h3 id='栈可能出现的问题'><span>栈可能出现的问题？</span></h3><ul><li><p><span>StackoverflowError</span></p><ul><li><p><span>采用固定大小的Java虚拟机栈</span></p><ul><li><span>线程请求分配的栈容量超过Java虚拟机栈允许的最大容量</span></li></ul></li></ul></li><li><p><span>outofMemoryError </span></p><ul><li><p><span>Java虚拟机栈可以动态扩展</span></p><ul><li><p><span>尝试扩展的时候无法申请到足够的内存</span></p><ul><li></li></ul></li><li><p><span>在创建新的线程时没有足够的内存去创建对应的虚拟机栈</span></p><ul><li><span>Integer存放Long类型</span></li></ul></li></ul></li></ul></li></ul><h3 id='举例栈溢出oom的情况'><span>举例栈溢出(OOM)的情况？</span></h3><ul><li><p><span>情况</span></p><ul><li><p><span>1、递归调用</span></p></li><li><p><span>2、大量循环或死循环</span></p></li><li><p><span>3、全局变量是否过多</span></p><ul><li><span>局部变量表过大</span></li></ul></li><li><p><span>4、数组、List、map数据是否过大</span></p></li></ul></li><li><p><span>解决方案</span></p><ul><li><span>使用DDMS工具进行查找大概出现栈溢出的位置</span></li></ul></li></ul><h3 id='调整栈大小就能保证不出现溢出么'><span>调整栈大小，就能保证不出现溢出么？</span></h3><ul><li><span>不能，还是存在</span></li></ul><h3 id='分配的栈内存越大越好么'><span>分配的栈内存越大越好么？</span></h3><ul><li><span>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的</span></li></ul><h3 id='垃圾回收是否涉及到虚拟机栈'><span>垃圾回收是否涉及到虚拟机栈？</span></h3><ul><li><span>不会，只有入栈出栈操作，不保留数据</span></li></ul><h3 id='方法中定义的局部变量是否线程安全'><span>方法中定义的局部变量是否线程安全？</span></h3><ul><li><span>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的</span></li></ul><h3 id='为什么private修饰的方法无法this调用'><span>为什么private修饰的方法无法this调用？</span></h3><ul><li><span>this变量不存在于局部变量表中</span></li></ul><h3 id='静态变量和局部变量的区别'><span>静态变量和局部变量的区别？</span></h3><ul><li><span>类变量有两次初始化时机(准备、初始化)，局部变量没有系统初始化过程。</span></li><li><span>类变量没有赋值可以使用，方法内局部变量不行</span></li></ul><h3 id='栈顶缓存技术'><span>栈顶缓存技术？</span></h3><ul><li><span>由于操作数是存储在内存中的，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</span></li></ul><h3 id='为什么需要常量池运行时常量池'><span>为什么需要常量池、运行时常量池？</span></h3><ul><li><p><span>常量池</span></p><ul><li><span>就是为了提供一些符号和常量，便于指令的识别（符号引用）</span></li><li><span>Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。</span></li></ul></li><li><p><span>运行时常量池</span></p><ul><li><span>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</span></li></ul></li></ul><h3 id='方法结束的方式'><span>方法结束的方式？</span></h3><ul><li><span>正常执行完成</span></li><li><span>出现未处理的异常，非正常退出</span></li></ul><h3 id='运行时数据区是否存在error和gc'><span>运行时数据区，是否存在Error和GC？</span></h3><ul><li><span>运行时数据区</span><span>	</span><span>是否存在Error</span><span>	</span><span>是否存在GC</span>
<span>程序计数器</span><span>	</span><span>否</span><span>	</span><span>否</span>
<span>虚拟机栈</span><span>	</span><span>是</span><span>	</span><span>否</span>
<span>本地方法栈</span><span>	</span><span>是</span><span>	</span><span>否</span>
<span>方法区</span><span>	</span><span>             是（OOM）</span><span>	</span><span>是</span>
<span>堆</span><span>	</span><span>             是</span><span>	</span><span>是</span></li></ul><p><span>### </span></p><h3 id='什么是stw'><span>什么是STW？</span></h3><ul><li><span>Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉。</span></li></ul><h3 id='为什么要把java堆分代不分代就不能正常工作了吗'><span>为什么要把Java堆分代？不分代就不能正常工作了吗？</span></h3><ul><li><span>1、经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</span></li><li><span>2、分代的唯一理由就是优化GC性能。</span></li><li><span>3、如果没有分代，GC的时候每次都会对堆的所有区域进行扫描，很耗时间。而很多对象都是临时对象，用分代的思想，新创建的对象放到某个地方，GC的时候首先对这块区域进行回收，可以提高堆的空间利用率。</span></li></ul><h3 id='堆空间都是共享的吗'><span>堆空间都是共享的吗？</span></h3><ul><li><span>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</span></li></ul><h3 id='为什么有tlab'><span>为什么有TLAB？</span></h3><ul><li><span>1、堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</span></li><li><span>2、由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。</span></li><li><span>3、为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</span></li></ul><h3 id='堆是分配对象的唯一选择么'><span>堆是分配对象的唯一选择么？</span></h3><ul><li><span>将堆上的对象分配到栈，需要使用逃逸分析手段</span></li></ul><p><span>### </span></p><h3 id='元空间与永久代的区别'><span>元空间与永久代的区别？</span></h3><ul><li><span>元空间不在虚拟机设置的内存中，而是使用本地内存</span></li><li><span>内部结构不同</span></li></ul><h3 id='如何解决oom'><span>如何解决OOM？</span></h3><ul><li><span>1、首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。</span></li><li><span>2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</span></li><li><span>3、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</span></li></ul><h3 id='static和static-final的区别'><span>static和static final的区别?</span></h3><ul><li><span>static修饰的变量在链接的准备阶段赋予默认值，初始化阶段真正赋值。</span></li><li><span>static final修饰的变量在编译阶段被分配(加载class文件时)</span></li></ul><h3 id='hotspot方法区的变化'><span>Hotspot方法区的变化？</span></h3><ul><li><span>JDK1.6及以前：有永久代，静态变量存储在永久代上</span></li><li><span>JDK1.7：有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中。</span></li><li><span>JDK1.8：无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</span></li></ul><h3 id='为什么永久代要被元空间替代'><span>为什么永久代要被元空间替代？</span></h3><ul><li><p><span>为永久代设置空间大小是很难确定的</span></p><ul><li><span>元空间的大小仅受本地内存限制。</span></li></ul></li><li><p><span>对永久代进行调优是很困难的</span></p><ul><li><span>Full GC才会回收，回收频率不高</span></li></ul></li></ul><h3 id='stringtable为什么要调整位置'><span>StringTable为什么要调整位置？</span></h3><ul><li><span>永久代的回收效率很低，在full gc的时候才会触发。而ful1gc是老年代的空间不足、永久代不足时才会触发。</span></li><li><span>永久代中的stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</span></li><li><span>永久代(permSize)空间较小，容易OOM</span></li></ul><p><span>### </span></p><h3 id='什么是直接内存'><span>什么是直接内存？</span></h3><ul><li><span>直接内存是在Java堆外的、直接向系统申请的内存区间。</span></li><li><span>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</span></li><li><span>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</span></li></ul><p><span>### </span></p><h3 id='为什么需要gc'><span>为什么需要gc？</span></h3><ul><li><span>如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收</span></li></ul><h3 id='不要主动调用某个对象的finalize方法应该交给垃圾回收机制调用'><span>不要主动调用某个对象的finalize方法,应该交给垃圾回收机制调用？</span></h3><ul><li><p><span>在finalize（）时可能会导致对象复活</span></p></li><li><p><span>一个糟糕的finalize（）会严重影响Gc的性能</span></p></li><li><p><span>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定</span></p><ul><li><span>优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</span></li></ul></li></ul><h3 id='分代算法和分区算法的区别'><span>分代算法和分区算法的区别？</span></h3><ul><li><span>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</span></li></ul><p><span>### </span></p><h3 id='你开发中使用过weakhashmap吗'><span>你开发中使用过WeakHashMap吗？</span></h3><ul><li><span>WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM</span></li></ul><h3 id='cms为什么不使用标记整理算法'><span>CMS为什么不使用标记整理算法？</span></h3><ul><li><span>标记整理算法会移动对象的内存地址，清除阶段用户线程依然在运行。</span></li></ul><h3 id='为什么cms是低延迟的'><span>为什么CMS是低延迟的？</span></h3><ul><li><span>最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</span></li></ul><h3 id='g1设置h的原因'><span>G1设置H的原因？</span></h3><ul><li><span>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。</span></li><li><span>G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Fu11Gc。</span></li></ul><p>&nbsp;</p></div></div>

<script>(function(){var e=document.body.parentElement,t=[],n=null,i=document.body.classList.contains("typora-export-collapse-outline"),r=function(e,t,n){document.addEventListener(e,function(e){if(!e.defaultPrevented)for(var i=e.target;i&&i!=this;i=i.parentNode)if(i.matches(t)){!1===n.call(i,e)&&(e.preventDefault(),e.stopPropagation());break}},!1)};function o(){return e.scrollTop}r("click",".outline-expander",function(e){var t=this.closest(".outline-item-wrapper").classList;return t.contains("outline-item-open")?t.remove("outline-item-open"):t.add("outline-item-open"),d(),!1}),r("click",".outline-item",function(e){var t=this.querySelector(".outline-label");if(location.hash="#"+t.getAttribute("href"),i){var n=this.closest(".outline-item-wrapper").classList;n.contains("outline-item-open")||n.add("outline-item-open"),c(),n.add("outline-item-active")}});var a,s,l=function(){var e=o();n=null;for(var i=0;i<t.length&&t[i][1]-e<60;i++)n=t[i]},c=function(){document.querySelectorAll(".outline-item-active").forEach(e=>e.classList.remove("outline-item-active")),document.querySelectorAll(".outline-item-single.outline-item-open").forEach(e=>e.classList.remove("outline-item-open"))},d=function(){if(n){c();var e=document.querySelector('.outline-label[href="#'+(CSS.escape?CSS.escape(n[0]):n[0])+'"]');if(e)if(i){var t=e.closest(".outline-item-open>ul>.outline-item-wrapper");if(t)t.classList.add("outline-item-active");else{for(var r=(e=e.closest(".outline-item-wrapper")).parentElement.closest(".outline-item-wrapper");r;)r=(e=r).parentElement.closest(".outline-item-wrapper");e.classList.add("outline-item-active")}}else e.closest(".outline-item-wrapper").classList.add("outline-item-active")}};window.addEventListener("scroll",function(e){a&&clearTimeout(a),a=setTimeout(function(){l(),d()},300)});var u=function(){s=setTimeout(function(){!function(){t=[];var e=o();document.querySelector("#write").querySelectorAll("h1, h2, h3, h4, h5, h6").forEach(n=>{var i=n.getAttribute("id");t.push([i,e+n.getBoundingClientRect().y])})}(),l(),d()},300)};window.addEventListener("resize",function(e){s&&clearTimeout(s),u()}),u()})();</script><a id="O-switch" style="width: 50px; height: 50px; text-align: center; line-height:50px; position:fixed; bottom:0; opacity: 0.3;" title="显示/隐藏目录">〇</a>

<script>
var sidebar = document.getElementsByClassName("typora-export-sidebar")[0];var button = document.getElementById("O-switch");sidebar.style.display='none';button.onclick=function(){if(sidebar.style.display=='block')sidebar.style.display='none';else sidebar.style.display='block'};
</script></body>
</html>